// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rtc_event_log2.proto

#include "rtc_event_log2.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace webrtc {
namespace rtclog2 {
PROTOBUF_CONSTEXPR EventStream::EventStream(
    ::_pbi::ConstantInitialized)
  : stream_()
  , incoming_rtp_packets_()
  , outgoing_rtp_packets_()
  , incoming_rtcp_packets_()
  , outgoing_rtcp_packets_()
  , audio_playout_events_()
  , frame_decoded_events_()
  , begin_log_events_()
  , end_log_events_()
  , loss_based_bwe_updates_()
  , delay_based_bwe_updates_()
  , audio_network_adaptations_()
  , probe_clusters_()
  , probe_success_()
  , probe_failure_()
  , alr_states_()
  , ice_candidate_configs_()
  , ice_candidate_events_()
  , dtls_transport_state_events_()
  , dtls_writable_states_()
  , generic_packets_sent_()
  , generic_packets_received_()
  , generic_acks_received_()
  , route_changes_()
  , remote_estimates_()
  , neteq_set_minimum_delay_()
  , audio_recv_stream_configs_()
  , audio_send_stream_configs_()
  , video_recv_stream_configs_()
  , video_send_stream_configs_(){}
struct EventStreamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventStreamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventStreamDefaultTypeInternal() {}
  union {
    EventStream _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventStreamDefaultTypeInternal _EventStream_default_instance_;
PROTOBUF_CONSTEXPR Event::Event(
    ::_pbi::ConstantInitialized){}
struct EventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventDefaultTypeInternal() {}
  union {
    Event _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventDefaultTypeInternal _Event_default_instance_;
PROTOBUF_CONSTEXPR GenericPacketReceived::GenericPacketReceived(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , packet_number_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , packet_length_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , packet_number_(int64_t{0})
  , packet_length_(0)
  , number_of_deltas_(0u){}
struct GenericPacketReceivedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenericPacketReceivedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenericPacketReceivedDefaultTypeInternal() {}
  union {
    GenericPacketReceived _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenericPacketReceivedDefaultTypeInternal _GenericPacketReceived_default_instance_;
PROTOBUF_CONSTEXPR GenericPacketSent::GenericPacketSent(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , packet_number_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , overhead_length_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , payload_length_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , padding_length_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , packet_number_(int64_t{0})
  , overhead_length_(0)
  , payload_length_(0)
  , padding_length_(0)
  , number_of_deltas_(0u){}
struct GenericPacketSentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenericPacketSentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenericPacketSentDefaultTypeInternal() {}
  union {
    GenericPacketSent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenericPacketSentDefaultTypeInternal _GenericPacketSent_default_instance_;
PROTOBUF_CONSTEXPR GenericAckReceived::GenericAckReceived(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , packet_number_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , acked_packet_number_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , receive_acked_packet_time_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , packet_number_(int64_t{0})
  , acked_packet_number_(int64_t{0})
  , receive_acked_packet_time_ms_(int64_t{0})
  , number_of_deltas_(0u){}
struct GenericAckReceivedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenericAckReceivedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenericAckReceivedDefaultTypeInternal() {}
  union {
    GenericAckReceived _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenericAckReceivedDefaultTypeInternal _GenericAckReceived_default_instance_;
PROTOBUF_CONSTEXPR DependencyDescriptorsWireInfo::DependencyDescriptorsWireInfo(
    ::_pbi::ConstantInitialized)
  : start_end_bit_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , template_id_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , frame_id_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , extended_infos_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , start_end_bit_(0u)
  , template_id_(0u)
  , frame_id_(0u){}
struct DependencyDescriptorsWireInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DependencyDescriptorsWireInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DependencyDescriptorsWireInfoDefaultTypeInternal() {}
  union {
    DependencyDescriptorsWireInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DependencyDescriptorsWireInfoDefaultTypeInternal _DependencyDescriptorsWireInfo_default_instance_;
PROTOBUF_CONSTEXPR IncomingRtpPackets::IncomingRtpPackets(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , marker_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , payload_type_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sequence_number_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rtp_timestamp_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ssrc_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , payload_size_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , header_size_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , padding_size_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , transport_sequence_number_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , transmission_time_offset_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , absolute_send_time_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , video_rotation_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , audio_level_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , voice_activity_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , dependency_descriptor_(nullptr)
  , timestamp_ms_(int64_t{0})
  , payload_type_(0u)
  , sequence_number_(0u)
  , rtp_timestamp_(0u)
  , ssrc_(0u)
  , payload_size_(0u)
  , header_size_(0u)
  , padding_size_(0u)
  , number_of_deltas_(0u)
  , marker_(false)
  , voice_activity_(false)
  , transport_sequence_number_(0u)
  , transmission_time_offset_(0)
  , absolute_send_time_(0u)
  , video_rotation_(0u)
  , audio_level_(0u){}
struct IncomingRtpPacketsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IncomingRtpPacketsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IncomingRtpPacketsDefaultTypeInternal() {}
  union {
    IncomingRtpPackets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IncomingRtpPacketsDefaultTypeInternal _IncomingRtpPackets_default_instance_;
PROTOBUF_CONSTEXPR OutgoingRtpPackets::OutgoingRtpPackets(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , marker_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , payload_type_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sequence_number_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rtp_timestamp_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ssrc_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , payload_size_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , header_size_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , padding_size_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , transport_sequence_number_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , transmission_time_offset_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , absolute_send_time_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , video_rotation_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , audio_level_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , voice_activity_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , dependency_descriptor_(nullptr)
  , timestamp_ms_(int64_t{0})
  , payload_type_(0u)
  , sequence_number_(0u)
  , rtp_timestamp_(0u)
  , ssrc_(0u)
  , payload_size_(0u)
  , header_size_(0u)
  , padding_size_(0u)
  , number_of_deltas_(0u)
  , marker_(false)
  , voice_activity_(false)
  , transport_sequence_number_(0u)
  , transmission_time_offset_(0)
  , absolute_send_time_(0u)
  , video_rotation_(0u)
  , audio_level_(0u){}
struct OutgoingRtpPacketsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OutgoingRtpPacketsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OutgoingRtpPacketsDefaultTypeInternal() {}
  union {
    OutgoingRtpPackets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OutgoingRtpPacketsDefaultTypeInternal _OutgoingRtpPackets_default_instance_;
PROTOBUF_CONSTEXPR IncomingRtcpPackets::IncomingRtcpPackets(
    ::_pbi::ConstantInitialized)
  : raw_packet_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , raw_packet_blobs_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , number_of_deltas_(0u){}
struct IncomingRtcpPacketsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IncomingRtcpPacketsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IncomingRtcpPacketsDefaultTypeInternal() {}
  union {
    IncomingRtcpPackets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IncomingRtcpPacketsDefaultTypeInternal _IncomingRtcpPackets_default_instance_;
PROTOBUF_CONSTEXPR OutgoingRtcpPackets::OutgoingRtcpPackets(
    ::_pbi::ConstantInitialized)
  : raw_packet_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , raw_packet_blobs_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , number_of_deltas_(0u){}
struct OutgoingRtcpPacketsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OutgoingRtcpPacketsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OutgoingRtcpPacketsDefaultTypeInternal() {}
  union {
    OutgoingRtcpPackets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OutgoingRtcpPacketsDefaultTypeInternal _OutgoingRtcpPackets_default_instance_;
PROTOBUF_CONSTEXPR AudioPlayoutEvents::AudioPlayoutEvents(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , local_ssrc_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , local_ssrc_(0u)
  , number_of_deltas_(0u){}
struct AudioPlayoutEventsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioPlayoutEventsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioPlayoutEventsDefaultTypeInternal() {}
  union {
    AudioPlayoutEvents _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioPlayoutEventsDefaultTypeInternal _AudioPlayoutEvents_default_instance_;
PROTOBUF_CONSTEXPR NetEqSetMinimumDelay::NetEqSetMinimumDelay(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , remote_ssrc_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , minimum_delay_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , remote_ssrc_(0u)
  , minimum_delay_ms_(0)
  , number_of_deltas_(0u){}
struct NetEqSetMinimumDelayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetEqSetMinimumDelayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetEqSetMinimumDelayDefaultTypeInternal() {}
  union {
    NetEqSetMinimumDelay _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetEqSetMinimumDelayDefaultTypeInternal _NetEqSetMinimumDelay_default_instance_;
PROTOBUF_CONSTEXPR FrameDecodedEvents::FrameDecodedEvents(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ssrc_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , render_time_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , width_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , height_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , codec_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , qp_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , render_time_ms_(int64_t{0})
  , ssrc_(0u)
  , width_(0)
  , height_(0)
  , codec_(0)

  , qp_(0u)
  , number_of_deltas_(0u){}
struct FrameDecodedEventsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameDecodedEventsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameDecodedEventsDefaultTypeInternal() {}
  union {
    FrameDecodedEvents _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameDecodedEventsDefaultTypeInternal _FrameDecodedEvents_default_instance_;
PROTOBUF_CONSTEXPR BeginLogEvent::BeginLogEvent(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0})
  , utc_time_ms_(int64_t{0})
  , version_(0u){}
struct BeginLogEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BeginLogEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BeginLogEventDefaultTypeInternal() {}
  union {
    BeginLogEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BeginLogEventDefaultTypeInternal _BeginLogEvent_default_instance_;
PROTOBUF_CONSTEXPR EndLogEvent::EndLogEvent(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0}){}
struct EndLogEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndLogEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndLogEventDefaultTypeInternal() {}
  union {
    EndLogEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndLogEventDefaultTypeInternal _EndLogEvent_default_instance_;
PROTOBUF_CONSTEXPR LossBasedBweUpdates::LossBasedBweUpdates(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , bitrate_bps_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , fraction_loss_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , total_packets_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , bitrate_bps_(0u)
  , fraction_loss_(0u)
  , total_packets_(0u)
  , number_of_deltas_(0u){}
struct LossBasedBweUpdatesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LossBasedBweUpdatesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LossBasedBweUpdatesDefaultTypeInternal() {}
  union {
    LossBasedBweUpdates _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LossBasedBweUpdatesDefaultTypeInternal _LossBasedBweUpdates_default_instance_;
PROTOBUF_CONSTEXPR DelayBasedBweUpdates::DelayBasedBweUpdates(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , bitrate_bps_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , detector_state_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , bitrate_bps_(0u)
  , detector_state_(0)

  , number_of_deltas_(0u){}
struct DelayBasedBweUpdatesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DelayBasedBweUpdatesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DelayBasedBweUpdatesDefaultTypeInternal() {}
  union {
    DelayBasedBweUpdates _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DelayBasedBweUpdatesDefaultTypeInternal _DelayBasedBweUpdates_default_instance_;
PROTOBUF_CONSTEXPR RtpHeaderExtensionConfig::RtpHeaderExtensionConfig(
    ::_pbi::ConstantInitialized)
  : transmission_time_offset_id_(0)
  , absolute_send_time_id_(0)
  , transport_sequence_number_id_(0)
  , video_rotation_id_(0)
  , audio_level_id_(0)
  , dependency_descriptor_id_(0){}
struct RtpHeaderExtensionConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RtpHeaderExtensionConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RtpHeaderExtensionConfigDefaultTypeInternal() {}
  union {
    RtpHeaderExtensionConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RtpHeaderExtensionConfigDefaultTypeInternal _RtpHeaderExtensionConfig_default_instance_;
PROTOBUF_CONSTEXPR VideoRecvStreamConfig::VideoRecvStreamConfig(
    ::_pbi::ConstantInitialized)
  : header_extensions_(nullptr)
  , timestamp_ms_(int64_t{0})
  , remote_ssrc_(0u)
  , local_ssrc_(0u)
  , rtx_ssrc_(0u){}
struct VideoRecvStreamConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoRecvStreamConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoRecvStreamConfigDefaultTypeInternal() {}
  union {
    VideoRecvStreamConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoRecvStreamConfigDefaultTypeInternal _VideoRecvStreamConfig_default_instance_;
PROTOBUF_CONSTEXPR VideoSendStreamConfig::VideoSendStreamConfig(
    ::_pbi::ConstantInitialized)
  : header_extensions_(nullptr)
  , timestamp_ms_(int64_t{0})
  , ssrc_(0u)
  , rtx_ssrc_(0u){}
struct VideoSendStreamConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoSendStreamConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoSendStreamConfigDefaultTypeInternal() {}
  union {
    VideoSendStreamConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoSendStreamConfigDefaultTypeInternal _VideoSendStreamConfig_default_instance_;
PROTOBUF_CONSTEXPR AudioRecvStreamConfig::AudioRecvStreamConfig(
    ::_pbi::ConstantInitialized)
  : header_extensions_(nullptr)
  , timestamp_ms_(int64_t{0})
  , remote_ssrc_(0u)
  , local_ssrc_(0u){}
struct AudioRecvStreamConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioRecvStreamConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioRecvStreamConfigDefaultTypeInternal() {}
  union {
    AudioRecvStreamConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioRecvStreamConfigDefaultTypeInternal _AudioRecvStreamConfig_default_instance_;
PROTOBUF_CONSTEXPR AudioSendStreamConfig::AudioSendStreamConfig(
    ::_pbi::ConstantInitialized)
  : header_extensions_(nullptr)
  , timestamp_ms_(int64_t{0})
  , ssrc_(0u){}
struct AudioSendStreamConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioSendStreamConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioSendStreamConfigDefaultTypeInternal() {}
  union {
    AudioSendStreamConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioSendStreamConfigDefaultTypeInternal _AudioSendStreamConfig_default_instance_;
PROTOBUF_CONSTEXPR AudioNetworkAdaptations::AudioNetworkAdaptations(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , bitrate_bps_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , frame_length_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , uplink_packet_loss_fraction_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , enable_fec_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , enable_dtx_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , num_channels_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , bitrate_bps_(0)
  , frame_length_ms_(0)
  , uplink_packet_loss_fraction_(0u)
  , enable_fec_(false)
  , enable_dtx_(false)
  , num_channels_(0u)
  , number_of_deltas_(0u){}
struct AudioNetworkAdaptationsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioNetworkAdaptationsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioNetworkAdaptationsDefaultTypeInternal() {}
  union {
    AudioNetworkAdaptations _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioNetworkAdaptationsDefaultTypeInternal _AudioNetworkAdaptations_default_instance_;
PROTOBUF_CONSTEXPR BweProbeCluster::BweProbeCluster(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0})
  , id_(0u)
  , bitrate_bps_(0u)
  , min_packets_(0u)
  , min_bytes_(0u){}
struct BweProbeClusterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BweProbeClusterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BweProbeClusterDefaultTypeInternal() {}
  union {
    BweProbeCluster _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BweProbeClusterDefaultTypeInternal _BweProbeCluster_default_instance_;
PROTOBUF_CONSTEXPR BweProbeResultSuccess::BweProbeResultSuccess(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0})
  , id_(0u)
  , bitrate_bps_(0u){}
struct BweProbeResultSuccessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BweProbeResultSuccessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BweProbeResultSuccessDefaultTypeInternal() {}
  union {
    BweProbeResultSuccess _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BweProbeResultSuccessDefaultTypeInternal _BweProbeResultSuccess_default_instance_;
PROTOBUF_CONSTEXPR BweProbeResultFailure::BweProbeResultFailure(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0})
  , id_(0u)
  , failure_(0)
{}
struct BweProbeResultFailureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BweProbeResultFailureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BweProbeResultFailureDefaultTypeInternal() {}
  union {
    BweProbeResultFailure _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BweProbeResultFailureDefaultTypeInternal _BweProbeResultFailure_default_instance_;
PROTOBUF_CONSTEXPR AlrState::AlrState(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0})
  , in_alr_(false){}
struct AlrStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AlrStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AlrStateDefaultTypeInternal() {}
  union {
    AlrState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AlrStateDefaultTypeInternal _AlrState_default_instance_;
PROTOBUF_CONSTEXPR IceCandidatePairConfig::IceCandidatePairConfig(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0})
  , config_type_(0)

  , candidate_pair_id_(0u)
  , local_candidate_type_(0)

  , local_relay_protocol_(0)

  , local_network_type_(0)

  , local_address_family_(0)

  , remote_candidate_type_(0)

  , remote_address_family_(0)

  , candidate_pair_protocol_(0)
{}
struct IceCandidatePairConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IceCandidatePairConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IceCandidatePairConfigDefaultTypeInternal() {}
  union {
    IceCandidatePairConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IceCandidatePairConfigDefaultTypeInternal _IceCandidatePairConfig_default_instance_;
PROTOBUF_CONSTEXPR IceCandidatePairEvent::IceCandidatePairEvent(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0})
  , event_type_(0)

  , candidate_pair_id_(0u)
  , transaction_id_(0u){}
struct IceCandidatePairEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IceCandidatePairEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IceCandidatePairEventDefaultTypeInternal() {}
  union {
    IceCandidatePairEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IceCandidatePairEventDefaultTypeInternal _IceCandidatePairEvent_default_instance_;
PROTOBUF_CONSTEXPR DtlsTransportStateEvent::DtlsTransportStateEvent(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0})
  , dtls_transport_state_(0)
{}
struct DtlsTransportStateEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DtlsTransportStateEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DtlsTransportStateEventDefaultTypeInternal() {}
  union {
    DtlsTransportStateEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DtlsTransportStateEventDefaultTypeInternal _DtlsTransportStateEvent_default_instance_;
PROTOBUF_CONSTEXPR DtlsWritableState::DtlsWritableState(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0})
  , writable_(false){}
struct DtlsWritableStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DtlsWritableStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DtlsWritableStateDefaultTypeInternal() {}
  union {
    DtlsWritableState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DtlsWritableStateDefaultTypeInternal _DtlsWritableState_default_instance_;
PROTOBUF_CONSTEXPR RouteChange::RouteChange(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0})
  , connected_(false)
  , overhead_(0u){}
struct RouteChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteChangeDefaultTypeInternal() {}
  union {
    RouteChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteChangeDefaultTypeInternal _RouteChange_default_instance_;
PROTOBUF_CONSTEXPR RemoteEstimates::RemoteEstimates(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , link_capacity_lower_kbps_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , link_capacity_upper_kbps_deltas_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_ms_(int64_t{0})
  , link_capacity_lower_kbps_(0u)
  , link_capacity_upper_kbps_(0u)
  , number_of_deltas_(0u){}
struct RemoteEstimatesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoteEstimatesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoteEstimatesDefaultTypeInternal() {}
  union {
    RemoteEstimates _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoteEstimatesDefaultTypeInternal _RemoteEstimates_default_instance_;
}  // namespace rtclog2
}  // namespace webrtc
namespace webrtc {
namespace rtclog2 {
bool FrameDecodedEvents_Codec_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FrameDecodedEvents_Codec_strings[7] = {};

static const char FrameDecodedEvents_Codec_names[] =
  "CODEC_AV1"
  "CODEC_GENERIC"
  "CODEC_H264"
  "CODEC_H265"
  "CODEC_UNKNOWN"
  "CODEC_VP8"
  "CODEC_VP9";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FrameDecodedEvents_Codec_entries[] = {
  { {FrameDecodedEvents_Codec_names + 0, 9}, 4 },
  { {FrameDecodedEvents_Codec_names + 9, 13}, 1 },
  { {FrameDecodedEvents_Codec_names + 22, 10}, 5 },
  { {FrameDecodedEvents_Codec_names + 32, 10}, 6 },
  { {FrameDecodedEvents_Codec_names + 42, 13}, 0 },
  { {FrameDecodedEvents_Codec_names + 55, 9}, 2 },
  { {FrameDecodedEvents_Codec_names + 64, 9}, 3 },
};

static const int FrameDecodedEvents_Codec_entries_by_number[] = {
  4, // 0 -> CODEC_UNKNOWN
  1, // 1 -> CODEC_GENERIC
  5, // 2 -> CODEC_VP8
  6, // 3 -> CODEC_VP9
  0, // 4 -> CODEC_AV1
  2, // 5 -> CODEC_H264
  3, // 6 -> CODEC_H265
};

const std::string& FrameDecodedEvents_Codec_Name(
    FrameDecodedEvents_Codec value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FrameDecodedEvents_Codec_entries,
          FrameDecodedEvents_Codec_entries_by_number,
          7, FrameDecodedEvents_Codec_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FrameDecodedEvents_Codec_entries,
      FrameDecodedEvents_Codec_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FrameDecodedEvents_Codec_strings[idx].get();
}
bool FrameDecodedEvents_Codec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FrameDecodedEvents_Codec* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FrameDecodedEvents_Codec_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<FrameDecodedEvents_Codec>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_UNKNOWN;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_GENERIC;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_VP8;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_VP9;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_AV1;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_H264;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_H265;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::Codec_MIN;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::Codec_MAX;
constexpr int FrameDecodedEvents::Codec_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DelayBasedBweUpdates_DetectorState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DelayBasedBweUpdates_DetectorState_strings[4] = {};

static const char DelayBasedBweUpdates_DetectorState_names[] =
  "BWE_NORMAL"
  "BWE_OVERUSING"
  "BWE_UNDERUSING"
  "BWE_UNKNOWN_STATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DelayBasedBweUpdates_DetectorState_entries[] = {
  { {DelayBasedBweUpdates_DetectorState_names + 0, 10}, 1 },
  { {DelayBasedBweUpdates_DetectorState_names + 10, 13}, 3 },
  { {DelayBasedBweUpdates_DetectorState_names + 23, 14}, 2 },
  { {DelayBasedBweUpdates_DetectorState_names + 37, 17}, 0 },
};

static const int DelayBasedBweUpdates_DetectorState_entries_by_number[] = {
  3, // 0 -> BWE_UNKNOWN_STATE
  0, // 1 -> BWE_NORMAL
  2, // 2 -> BWE_UNDERUSING
  1, // 3 -> BWE_OVERUSING
};

const std::string& DelayBasedBweUpdates_DetectorState_Name(
    DelayBasedBweUpdates_DetectorState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DelayBasedBweUpdates_DetectorState_entries,
          DelayBasedBweUpdates_DetectorState_entries_by_number,
          4, DelayBasedBweUpdates_DetectorState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DelayBasedBweUpdates_DetectorState_entries,
      DelayBasedBweUpdates_DetectorState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DelayBasedBweUpdates_DetectorState_strings[idx].get();
}
bool DelayBasedBweUpdates_DetectorState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DelayBasedBweUpdates_DetectorState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DelayBasedBweUpdates_DetectorState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DelayBasedBweUpdates_DetectorState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::BWE_UNKNOWN_STATE;
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::BWE_NORMAL;
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::BWE_UNDERUSING;
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::BWE_OVERUSING;
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::DetectorState_MIN;
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::DetectorState_MAX;
constexpr int DelayBasedBweUpdates::DetectorState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BweProbeResultFailure_FailureReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BweProbeResultFailure_FailureReason_strings[4] = {};

static const char BweProbeResultFailure_FailureReason_names[] =
  "INVALID_SEND_RECEIVE_INTERVAL"
  "INVALID_SEND_RECEIVE_RATIO"
  "TIMEOUT"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BweProbeResultFailure_FailureReason_entries[] = {
  { {BweProbeResultFailure_FailureReason_names + 0, 29}, 1 },
  { {BweProbeResultFailure_FailureReason_names + 29, 26}, 2 },
  { {BweProbeResultFailure_FailureReason_names + 55, 7}, 3 },
  { {BweProbeResultFailure_FailureReason_names + 62, 7}, 0 },
};

static const int BweProbeResultFailure_FailureReason_entries_by_number[] = {
  3, // 0 -> UNKNOWN
  0, // 1 -> INVALID_SEND_RECEIVE_INTERVAL
  1, // 2 -> INVALID_SEND_RECEIVE_RATIO
  2, // 3 -> TIMEOUT
};

const std::string& BweProbeResultFailure_FailureReason_Name(
    BweProbeResultFailure_FailureReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BweProbeResultFailure_FailureReason_entries,
          BweProbeResultFailure_FailureReason_entries_by_number,
          4, BweProbeResultFailure_FailureReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BweProbeResultFailure_FailureReason_entries,
      BweProbeResultFailure_FailureReason_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BweProbeResultFailure_FailureReason_strings[idx].get();
}
bool BweProbeResultFailure_FailureReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BweProbeResultFailure_FailureReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BweProbeResultFailure_FailureReason_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<BweProbeResultFailure_FailureReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::UNKNOWN;
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::INVALID_SEND_RECEIVE_INTERVAL;
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::INVALID_SEND_RECEIVE_RATIO;
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::TIMEOUT;
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::FailureReason_MIN;
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::FailureReason_MAX;
constexpr int BweProbeResultFailure::FailureReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool IceCandidatePairConfig_IceCandidatePairConfigType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> IceCandidatePairConfig_IceCandidatePairConfigType_strings[5] = {};

static const char IceCandidatePairConfig_IceCandidatePairConfigType_names[] =
  "ADDED"
  "DESTROYED"
  "SELECTED"
  "UNKNOWN_CONFIG_TYPE"
  "UPDATED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry IceCandidatePairConfig_IceCandidatePairConfigType_entries[] = {
  { {IceCandidatePairConfig_IceCandidatePairConfigType_names + 0, 5}, 1 },
  { {IceCandidatePairConfig_IceCandidatePairConfigType_names + 5, 9}, 3 },
  { {IceCandidatePairConfig_IceCandidatePairConfigType_names + 14, 8}, 4 },
  { {IceCandidatePairConfig_IceCandidatePairConfigType_names + 22, 19}, 0 },
  { {IceCandidatePairConfig_IceCandidatePairConfigType_names + 41, 7}, 2 },
};

static const int IceCandidatePairConfig_IceCandidatePairConfigType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_CONFIG_TYPE
  0, // 1 -> ADDED
  4, // 2 -> UPDATED
  1, // 3 -> DESTROYED
  2, // 4 -> SELECTED
};

const std::string& IceCandidatePairConfig_IceCandidatePairConfigType_Name(
    IceCandidatePairConfig_IceCandidatePairConfigType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          IceCandidatePairConfig_IceCandidatePairConfigType_entries,
          IceCandidatePairConfig_IceCandidatePairConfigType_entries_by_number,
          5, IceCandidatePairConfig_IceCandidatePairConfigType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      IceCandidatePairConfig_IceCandidatePairConfigType_entries,
      IceCandidatePairConfig_IceCandidatePairConfigType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     IceCandidatePairConfig_IceCandidatePairConfigType_strings[idx].get();
}
bool IceCandidatePairConfig_IceCandidatePairConfigType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IceCandidatePairConfig_IceCandidatePairConfigType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      IceCandidatePairConfig_IceCandidatePairConfigType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairConfig_IceCandidatePairConfigType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::UNKNOWN_CONFIG_TYPE;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::ADDED;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::UPDATED;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::DESTROYED;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::SELECTED;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::IceCandidatePairConfigType_MIN;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::IceCandidatePairConfigType_MAX;
constexpr int IceCandidatePairConfig::IceCandidatePairConfigType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool IceCandidatePairConfig_IceCandidateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> IceCandidatePairConfig_IceCandidateType_strings[5] = {};

static const char IceCandidatePairConfig_IceCandidateType_names[] =
  "LOCAL"
  "PRFLX"
  "RELAY"
  "STUN"
  "UNKNOWN_CANDIDATE_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry IceCandidatePairConfig_IceCandidateType_entries[] = {
  { {IceCandidatePairConfig_IceCandidateType_names + 0, 5}, 1 },
  { {IceCandidatePairConfig_IceCandidateType_names + 5, 5}, 3 },
  { {IceCandidatePairConfig_IceCandidateType_names + 10, 5}, 4 },
  { {IceCandidatePairConfig_IceCandidateType_names + 15, 4}, 2 },
  { {IceCandidatePairConfig_IceCandidateType_names + 19, 22}, 0 },
};

static const int IceCandidatePairConfig_IceCandidateType_entries_by_number[] = {
  4, // 0 -> UNKNOWN_CANDIDATE_TYPE
  0, // 1 -> LOCAL
  3, // 2 -> STUN
  1, // 3 -> PRFLX
  2, // 4 -> RELAY
};

const std::string& IceCandidatePairConfig_IceCandidateType_Name(
    IceCandidatePairConfig_IceCandidateType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          IceCandidatePairConfig_IceCandidateType_entries,
          IceCandidatePairConfig_IceCandidateType_entries_by_number,
          5, IceCandidatePairConfig_IceCandidateType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      IceCandidatePairConfig_IceCandidateType_entries,
      IceCandidatePairConfig_IceCandidateType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     IceCandidatePairConfig_IceCandidateType_strings[idx].get();
}
bool IceCandidatePairConfig_IceCandidateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IceCandidatePairConfig_IceCandidateType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      IceCandidatePairConfig_IceCandidateType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairConfig_IceCandidateType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::UNKNOWN_CANDIDATE_TYPE;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::LOCAL;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::STUN;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::PRFLX;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::RELAY;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::IceCandidateType_MIN;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::IceCandidateType_MAX;
constexpr int IceCandidatePairConfig::IceCandidateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool IceCandidatePairConfig_Protocol_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> IceCandidatePairConfig_Protocol_strings[5] = {};

static const char IceCandidatePairConfig_Protocol_names[] =
  "SSLTCP"
  "TCP"
  "TLS"
  "UDP"
  "UNKNOWN_PROTOCOL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry IceCandidatePairConfig_Protocol_entries[] = {
  { {IceCandidatePairConfig_Protocol_names + 0, 6}, 3 },
  { {IceCandidatePairConfig_Protocol_names + 6, 3}, 2 },
  { {IceCandidatePairConfig_Protocol_names + 9, 3}, 4 },
  { {IceCandidatePairConfig_Protocol_names + 12, 3}, 1 },
  { {IceCandidatePairConfig_Protocol_names + 15, 16}, 0 },
};

static const int IceCandidatePairConfig_Protocol_entries_by_number[] = {
  4, // 0 -> UNKNOWN_PROTOCOL
  3, // 1 -> UDP
  1, // 2 -> TCP
  0, // 3 -> SSLTCP
  2, // 4 -> TLS
};

const std::string& IceCandidatePairConfig_Protocol_Name(
    IceCandidatePairConfig_Protocol value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          IceCandidatePairConfig_Protocol_entries,
          IceCandidatePairConfig_Protocol_entries_by_number,
          5, IceCandidatePairConfig_Protocol_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      IceCandidatePairConfig_Protocol_entries,
      IceCandidatePairConfig_Protocol_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     IceCandidatePairConfig_Protocol_strings[idx].get();
}
bool IceCandidatePairConfig_Protocol_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IceCandidatePairConfig_Protocol* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      IceCandidatePairConfig_Protocol_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairConfig_Protocol>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::UNKNOWN_PROTOCOL;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::UDP;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::TCP;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::SSLTCP;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::TLS;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::Protocol_MIN;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::Protocol_MAX;
constexpr int IceCandidatePairConfig::Protocol_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool IceCandidatePairConfig_AddressFamily_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> IceCandidatePairConfig_AddressFamily_strings[3] = {};

static const char IceCandidatePairConfig_AddressFamily_names[] =
  "IPV4"
  "IPV6"
  "UNKNOWN_ADDRESS_FAMILY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry IceCandidatePairConfig_AddressFamily_entries[] = {
  { {IceCandidatePairConfig_AddressFamily_names + 0, 4}, 1 },
  { {IceCandidatePairConfig_AddressFamily_names + 4, 4}, 2 },
  { {IceCandidatePairConfig_AddressFamily_names + 8, 22}, 0 },
};

static const int IceCandidatePairConfig_AddressFamily_entries_by_number[] = {
  2, // 0 -> UNKNOWN_ADDRESS_FAMILY
  0, // 1 -> IPV4
  1, // 2 -> IPV6
};

const std::string& IceCandidatePairConfig_AddressFamily_Name(
    IceCandidatePairConfig_AddressFamily value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          IceCandidatePairConfig_AddressFamily_entries,
          IceCandidatePairConfig_AddressFamily_entries_by_number,
          3, IceCandidatePairConfig_AddressFamily_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      IceCandidatePairConfig_AddressFamily_entries,
      IceCandidatePairConfig_AddressFamily_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     IceCandidatePairConfig_AddressFamily_strings[idx].get();
}
bool IceCandidatePairConfig_AddressFamily_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IceCandidatePairConfig_AddressFamily* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      IceCandidatePairConfig_AddressFamily_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairConfig_AddressFamily>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::UNKNOWN_ADDRESS_FAMILY;
constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::IPV4;
constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::IPV6;
constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::AddressFamily_MIN;
constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::AddressFamily_MAX;
constexpr int IceCandidatePairConfig::AddressFamily_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool IceCandidatePairConfig_NetworkType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> IceCandidatePairConfig_NetworkType_strings[6] = {};

static const char IceCandidatePairConfig_NetworkType_names[] =
  "CELLULAR"
  "ETHERNET"
  "LOOPBACK"
  "UNKNOWN_NETWORK_TYPE"
  "VPN"
  "WIFI";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry IceCandidatePairConfig_NetworkType_entries[] = {
  { {IceCandidatePairConfig_NetworkType_names + 0, 8}, 3 },
  { {IceCandidatePairConfig_NetworkType_names + 8, 8}, 1 },
  { {IceCandidatePairConfig_NetworkType_names + 16, 8}, 5 },
  { {IceCandidatePairConfig_NetworkType_names + 24, 20}, 0 },
  { {IceCandidatePairConfig_NetworkType_names + 44, 3}, 4 },
  { {IceCandidatePairConfig_NetworkType_names + 47, 4}, 2 },
};

static const int IceCandidatePairConfig_NetworkType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_NETWORK_TYPE
  1, // 1 -> ETHERNET
  5, // 2 -> WIFI
  0, // 3 -> CELLULAR
  4, // 4 -> VPN
  2, // 5 -> LOOPBACK
};

const std::string& IceCandidatePairConfig_NetworkType_Name(
    IceCandidatePairConfig_NetworkType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          IceCandidatePairConfig_NetworkType_entries,
          IceCandidatePairConfig_NetworkType_entries_by_number,
          6, IceCandidatePairConfig_NetworkType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      IceCandidatePairConfig_NetworkType_entries,
      IceCandidatePairConfig_NetworkType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     IceCandidatePairConfig_NetworkType_strings[idx].get();
}
bool IceCandidatePairConfig_NetworkType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IceCandidatePairConfig_NetworkType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      IceCandidatePairConfig_NetworkType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairConfig_NetworkType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::UNKNOWN_NETWORK_TYPE;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::ETHERNET;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::WIFI;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::CELLULAR;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::VPN;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::LOOPBACK;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::NetworkType_MIN;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::NetworkType_MAX;
constexpr int IceCandidatePairConfig::NetworkType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool IceCandidatePairEvent_IceCandidatePairEventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> IceCandidatePairEvent_IceCandidatePairEventType_strings[5] = {};

static const char IceCandidatePairEvent_IceCandidatePairEventType_names[] =
  "CHECK_RECEIVED"
  "CHECK_RESPONSE_RECEIVED"
  "CHECK_RESPONSE_SENT"
  "CHECK_SENT"
  "UNKNOWN_CHECK_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry IceCandidatePairEvent_IceCandidatePairEventType_entries[] = {
  { {IceCandidatePairEvent_IceCandidatePairEventType_names + 0, 14}, 2 },
  { {IceCandidatePairEvent_IceCandidatePairEventType_names + 14, 23}, 4 },
  { {IceCandidatePairEvent_IceCandidatePairEventType_names + 37, 19}, 3 },
  { {IceCandidatePairEvent_IceCandidatePairEventType_names + 56, 10}, 1 },
  { {IceCandidatePairEvent_IceCandidatePairEventType_names + 66, 18}, 0 },
};

static const int IceCandidatePairEvent_IceCandidatePairEventType_entries_by_number[] = {
  4, // 0 -> UNKNOWN_CHECK_TYPE
  3, // 1 -> CHECK_SENT
  0, // 2 -> CHECK_RECEIVED
  2, // 3 -> CHECK_RESPONSE_SENT
  1, // 4 -> CHECK_RESPONSE_RECEIVED
};

const std::string& IceCandidatePairEvent_IceCandidatePairEventType_Name(
    IceCandidatePairEvent_IceCandidatePairEventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          IceCandidatePairEvent_IceCandidatePairEventType_entries,
          IceCandidatePairEvent_IceCandidatePairEventType_entries_by_number,
          5, IceCandidatePairEvent_IceCandidatePairEventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      IceCandidatePairEvent_IceCandidatePairEventType_entries,
      IceCandidatePairEvent_IceCandidatePairEventType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     IceCandidatePairEvent_IceCandidatePairEventType_strings[idx].get();
}
bool IceCandidatePairEvent_IceCandidatePairEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IceCandidatePairEvent_IceCandidatePairEventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      IceCandidatePairEvent_IceCandidatePairEventType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairEvent_IceCandidatePairEventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::UNKNOWN_CHECK_TYPE;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::CHECK_SENT;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::CHECK_RECEIVED;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::CHECK_RESPONSE_SENT;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::CHECK_RESPONSE_RECEIVED;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::IceCandidatePairEventType_MIN;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::IceCandidatePairEventType_MAX;
constexpr int IceCandidatePairEvent::IceCandidatePairEventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DtlsTransportStateEvent_DtlsTransportState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DtlsTransportStateEvent_DtlsTransportState_strings[6] = {};

static const char DtlsTransportStateEvent_DtlsTransportState_names[] =
  "DTLS_TRANSPORT_CLOSED"
  "DTLS_TRANSPORT_CONNECTED"
  "DTLS_TRANSPORT_CONNECTING"
  "DTLS_TRANSPORT_FAILED"
  "DTLS_TRANSPORT_NEW"
  "UNKNOWN_DTLS_TRANSPORT_STATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DtlsTransportStateEvent_DtlsTransportState_entries[] = {
  { {DtlsTransportStateEvent_DtlsTransportState_names + 0, 21}, 4 },
  { {DtlsTransportStateEvent_DtlsTransportState_names + 21, 24}, 3 },
  { {DtlsTransportStateEvent_DtlsTransportState_names + 45, 25}, 2 },
  { {DtlsTransportStateEvent_DtlsTransportState_names + 70, 21}, 5 },
  { {DtlsTransportStateEvent_DtlsTransportState_names + 91, 18}, 1 },
  { {DtlsTransportStateEvent_DtlsTransportState_names + 109, 28}, 0 },
};

static const int DtlsTransportStateEvent_DtlsTransportState_entries_by_number[] = {
  5, // 0 -> UNKNOWN_DTLS_TRANSPORT_STATE
  4, // 1 -> DTLS_TRANSPORT_NEW
  2, // 2 -> DTLS_TRANSPORT_CONNECTING
  1, // 3 -> DTLS_TRANSPORT_CONNECTED
  0, // 4 -> DTLS_TRANSPORT_CLOSED
  3, // 5 -> DTLS_TRANSPORT_FAILED
};

const std::string& DtlsTransportStateEvent_DtlsTransportState_Name(
    DtlsTransportStateEvent_DtlsTransportState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DtlsTransportStateEvent_DtlsTransportState_entries,
          DtlsTransportStateEvent_DtlsTransportState_entries_by_number,
          6, DtlsTransportStateEvent_DtlsTransportState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DtlsTransportStateEvent_DtlsTransportState_entries,
      DtlsTransportStateEvent_DtlsTransportState_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DtlsTransportStateEvent_DtlsTransportState_strings[idx].get();
}
bool DtlsTransportStateEvent_DtlsTransportState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DtlsTransportStateEvent_DtlsTransportState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DtlsTransportStateEvent_DtlsTransportState_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<DtlsTransportStateEvent_DtlsTransportState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::UNKNOWN_DTLS_TRANSPORT_STATE;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DTLS_TRANSPORT_NEW;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DTLS_TRANSPORT_CONNECTING;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DTLS_TRANSPORT_CONNECTED;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DTLS_TRANSPORT_CLOSED;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DTLS_TRANSPORT_FAILED;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DtlsTransportState_MIN;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DtlsTransportState_MAX;
constexpr int DtlsTransportStateEvent::DtlsTransportState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class EventStream::_Internal {
 public:
};

EventStream::EventStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  stream_(arena),
  incoming_rtp_packets_(arena),
  outgoing_rtp_packets_(arena),
  incoming_rtcp_packets_(arena),
  outgoing_rtcp_packets_(arena),
  audio_playout_events_(arena),
  frame_decoded_events_(arena),
  begin_log_events_(arena),
  end_log_events_(arena),
  loss_based_bwe_updates_(arena),
  delay_based_bwe_updates_(arena),
  audio_network_adaptations_(arena),
  probe_clusters_(arena),
  probe_success_(arena),
  probe_failure_(arena),
  alr_states_(arena),
  ice_candidate_configs_(arena),
  ice_candidate_events_(arena),
  dtls_transport_state_events_(arena),
  dtls_writable_states_(arena),
  generic_packets_sent_(arena),
  generic_packets_received_(arena),
  generic_acks_received_(arena),
  route_changes_(arena),
  remote_estimates_(arena),
  neteq_set_minimum_delay_(arena),
  audio_recv_stream_configs_(arena),
  audio_send_stream_configs_(arena),
  video_recv_stream_configs_(arena),
  video_send_stream_configs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.EventStream)
}
EventStream::EventStream(const EventStream& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      stream_(from.stream_),
      incoming_rtp_packets_(from.incoming_rtp_packets_),
      outgoing_rtp_packets_(from.outgoing_rtp_packets_),
      incoming_rtcp_packets_(from.incoming_rtcp_packets_),
      outgoing_rtcp_packets_(from.outgoing_rtcp_packets_),
      audio_playout_events_(from.audio_playout_events_),
      frame_decoded_events_(from.frame_decoded_events_),
      begin_log_events_(from.begin_log_events_),
      end_log_events_(from.end_log_events_),
      loss_based_bwe_updates_(from.loss_based_bwe_updates_),
      delay_based_bwe_updates_(from.delay_based_bwe_updates_),
      audio_network_adaptations_(from.audio_network_adaptations_),
      probe_clusters_(from.probe_clusters_),
      probe_success_(from.probe_success_),
      probe_failure_(from.probe_failure_),
      alr_states_(from.alr_states_),
      ice_candidate_configs_(from.ice_candidate_configs_),
      ice_candidate_events_(from.ice_candidate_events_),
      dtls_transport_state_events_(from.dtls_transport_state_events_),
      dtls_writable_states_(from.dtls_writable_states_),
      generic_packets_sent_(from.generic_packets_sent_),
      generic_packets_received_(from.generic_packets_received_),
      generic_acks_received_(from.generic_acks_received_),
      route_changes_(from.route_changes_),
      remote_estimates_(from.remote_estimates_),
      neteq_set_minimum_delay_(from.neteq_set_minimum_delay_),
      audio_recv_stream_configs_(from.audio_recv_stream_configs_),
      audio_send_stream_configs_(from.audio_send_stream_configs_),
      video_recv_stream_configs_(from.video_recv_stream_configs_),
      video_send_stream_configs_(from.video_send_stream_configs_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.EventStream)
}

inline void EventStream::SharedCtor() {
}

EventStream::~EventStream() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.EventStream)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventStream::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EventStream::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EventStream::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.EventStream)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stream_.Clear();
  incoming_rtp_packets_.Clear();
  outgoing_rtp_packets_.Clear();
  incoming_rtcp_packets_.Clear();
  outgoing_rtcp_packets_.Clear();
  audio_playout_events_.Clear();
  frame_decoded_events_.Clear();
  begin_log_events_.Clear();
  end_log_events_.Clear();
  loss_based_bwe_updates_.Clear();
  delay_based_bwe_updates_.Clear();
  audio_network_adaptations_.Clear();
  probe_clusters_.Clear();
  probe_success_.Clear();
  probe_failure_.Clear();
  alr_states_.Clear();
  ice_candidate_configs_.Clear();
  ice_candidate_events_.Clear();
  dtls_transport_state_events_.Clear();
  dtls_writable_states_.Clear();
  generic_packets_sent_.Clear();
  generic_packets_received_.Clear();
  generic_acks_received_.Clear();
  route_changes_.Clear();
  remote_estimates_.Clear();
  neteq_set_minimum_delay_.Clear();
  audio_recv_stream_configs_.Clear();
  audio_send_stream_configs_.Clear();
  video_recv_stream_configs_.Clear();
  video_send_stream_configs_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EventStream::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .webrtc.rtclog2.Event stream = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stream(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.IncomingRtpPackets incoming_rtp_packets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_incoming_rtp_packets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.OutgoingRtpPackets outgoing_rtp_packets = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_outgoing_rtp_packets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.IncomingRtcpPackets incoming_rtcp_packets = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_incoming_rtcp_packets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.OutgoingRtcpPackets outgoing_rtcp_packets = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_outgoing_rtcp_packets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.AudioPlayoutEvents audio_playout_events = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_audio_playout_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.FrameDecodedEvents frame_decoded_events = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_frame_decoded_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.BeginLogEvent begin_log_events = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_begin_log_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.EndLogEvent end_log_events = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_end_log_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.LossBasedBweUpdates loss_based_bwe_updates = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_loss_based_bwe_updates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.DelayBasedBweUpdates delay_based_bwe_updates = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_delay_based_bwe_updates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<154>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.AudioNetworkAdaptations audio_network_adaptations = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_audio_network_adaptations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.BweProbeCluster probe_clusters = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_probe_clusters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.BweProbeResultSuccess probe_success = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_probe_success(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.BweProbeResultFailure probe_failure = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_probe_failure(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.AlrState alr_states = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_alr_states(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<194>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.IceCandidatePairConfig ice_candidate_configs = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_ice_candidate_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<202>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.IceCandidatePairEvent ice_candidate_events = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_ice_candidate_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<210>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.DtlsTransportStateEvent dtls_transport_state_events = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_dtls_transport_state_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<218>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.DtlsWritableState dtls_writable_states = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_dtls_writable_states(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<226>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.GenericPacketSent generic_packets_sent = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_generic_packets_sent(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<234>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.GenericPacketReceived generic_packets_received = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_generic_packets_received(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<242>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.GenericAckReceived generic_acks_received = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_generic_acks_received(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<250>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.RouteChange route_changes = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_route_changes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<258>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.RemoteEstimates remote_estimates = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_remote_estimates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<266>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.NetEqSetMinimumDelay neteq_set_minimum_delay = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_neteq_set_minimum_delay(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<274>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.AudioRecvStreamConfig audio_recv_stream_configs = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_audio_recv_stream_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<810>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.AudioSendStreamConfig audio_send_stream_configs = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_audio_send_stream_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<818>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.VideoRecvStreamConfig video_recv_stream_configs = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_video_recv_stream_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<826>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .webrtc.rtclog2.VideoSendStreamConfig video_send_stream_configs = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_video_send_stream_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<834>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EventStream::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.EventStream)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .webrtc.rtclog2.Event stream = 1 [deprecated = true];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stream_size()); i < n; i++) {
    const auto& repfield = this->_internal_stream(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.IncomingRtpPackets incoming_rtp_packets = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_incoming_rtp_packets_size()); i < n; i++) {
    const auto& repfield = this->_internal_incoming_rtp_packets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.OutgoingRtpPackets outgoing_rtp_packets = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outgoing_rtp_packets_size()); i < n; i++) {
    const auto& repfield = this->_internal_outgoing_rtp_packets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.IncomingRtcpPackets incoming_rtcp_packets = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_incoming_rtcp_packets_size()); i < n; i++) {
    const auto& repfield = this->_internal_incoming_rtcp_packets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.OutgoingRtcpPackets outgoing_rtcp_packets = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outgoing_rtcp_packets_size()); i < n; i++) {
    const auto& repfield = this->_internal_outgoing_rtcp_packets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.AudioPlayoutEvents audio_playout_events = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_audio_playout_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_audio_playout_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.FrameDecodedEvents frame_decoded_events = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_frame_decoded_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_frame_decoded_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.BeginLogEvent begin_log_events = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_begin_log_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_begin_log_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.EndLogEvent end_log_events = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_end_log_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_end_log_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.LossBasedBweUpdates loss_based_bwe_updates = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_loss_based_bwe_updates_size()); i < n; i++) {
    const auto& repfield = this->_internal_loss_based_bwe_updates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.DelayBasedBweUpdates delay_based_bwe_updates = 19;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_delay_based_bwe_updates_size()); i < n; i++) {
    const auto& repfield = this->_internal_delay_based_bwe_updates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.AudioNetworkAdaptations audio_network_adaptations = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_audio_network_adaptations_size()); i < n; i++) {
    const auto& repfield = this->_internal_audio_network_adaptations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.BweProbeCluster probe_clusters = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_probe_clusters_size()); i < n; i++) {
    const auto& repfield = this->_internal_probe_clusters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.BweProbeResultSuccess probe_success = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_probe_success_size()); i < n; i++) {
    const auto& repfield = this->_internal_probe_success(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.BweProbeResultFailure probe_failure = 23;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_probe_failure_size()); i < n; i++) {
    const auto& repfield = this->_internal_probe_failure(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(23, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.AlrState alr_states = 24;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_alr_states_size()); i < n; i++) {
    const auto& repfield = this->_internal_alr_states(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(24, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.IceCandidatePairConfig ice_candidate_configs = 25;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ice_candidate_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_ice_candidate_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(25, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.IceCandidatePairEvent ice_candidate_events = 26;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ice_candidate_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_ice_candidate_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(26, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.DtlsTransportStateEvent dtls_transport_state_events = 27;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dtls_transport_state_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_dtls_transport_state_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(27, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.DtlsWritableState dtls_writable_states = 28;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dtls_writable_states_size()); i < n; i++) {
    const auto& repfield = this->_internal_dtls_writable_states(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(28, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.GenericPacketSent generic_packets_sent = 29;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_generic_packets_sent_size()); i < n; i++) {
    const auto& repfield = this->_internal_generic_packets_sent(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(29, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.GenericPacketReceived generic_packets_received = 30;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_generic_packets_received_size()); i < n; i++) {
    const auto& repfield = this->_internal_generic_packets_received(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(30, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.GenericAckReceived generic_acks_received = 31;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_generic_acks_received_size()); i < n; i++) {
    const auto& repfield = this->_internal_generic_acks_received(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(31, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.RouteChange route_changes = 32;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_route_changes_size()); i < n; i++) {
    const auto& repfield = this->_internal_route_changes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(32, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.RemoteEstimates remote_estimates = 33;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_remote_estimates_size()); i < n; i++) {
    const auto& repfield = this->_internal_remote_estimates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(33, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.NetEqSetMinimumDelay neteq_set_minimum_delay = 34;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_neteq_set_minimum_delay_size()); i < n; i++) {
    const auto& repfield = this->_internal_neteq_set_minimum_delay(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(34, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.AudioRecvStreamConfig audio_recv_stream_configs = 101;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_audio_recv_stream_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_audio_recv_stream_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(101, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.AudioSendStreamConfig audio_send_stream_configs = 102;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_audio_send_stream_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_audio_send_stream_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(102, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.VideoRecvStreamConfig video_recv_stream_configs = 103;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_video_recv_stream_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_video_recv_stream_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(103, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.VideoSendStreamConfig video_send_stream_configs = 104;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_video_send_stream_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_video_send_stream_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(104, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.EventStream)
  return target;
}

size_t EventStream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.EventStream)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .webrtc.rtclog2.Event stream = 1 [deprecated = true];
  total_size += 1UL * this->_internal_stream_size();
  for (const auto& msg : this->stream_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.IncomingRtpPackets incoming_rtp_packets = 2;
  total_size += 1UL * this->_internal_incoming_rtp_packets_size();
  for (const auto& msg : this->incoming_rtp_packets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.OutgoingRtpPackets outgoing_rtp_packets = 3;
  total_size += 1UL * this->_internal_outgoing_rtp_packets_size();
  for (const auto& msg : this->outgoing_rtp_packets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.IncomingRtcpPackets incoming_rtcp_packets = 4;
  total_size += 1UL * this->_internal_incoming_rtcp_packets_size();
  for (const auto& msg : this->incoming_rtcp_packets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.OutgoingRtcpPackets outgoing_rtcp_packets = 5;
  total_size += 1UL * this->_internal_outgoing_rtcp_packets_size();
  for (const auto& msg : this->outgoing_rtcp_packets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.AudioPlayoutEvents audio_playout_events = 6;
  total_size += 1UL * this->_internal_audio_playout_events_size();
  for (const auto& msg : this->audio_playout_events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.FrameDecodedEvents frame_decoded_events = 7;
  total_size += 1UL * this->_internal_frame_decoded_events_size();
  for (const auto& msg : this->frame_decoded_events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.BeginLogEvent begin_log_events = 16;
  total_size += 2UL * this->_internal_begin_log_events_size();
  for (const auto& msg : this->begin_log_events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.EndLogEvent end_log_events = 17;
  total_size += 2UL * this->_internal_end_log_events_size();
  for (const auto& msg : this->end_log_events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.LossBasedBweUpdates loss_based_bwe_updates = 18;
  total_size += 2UL * this->_internal_loss_based_bwe_updates_size();
  for (const auto& msg : this->loss_based_bwe_updates_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.DelayBasedBweUpdates delay_based_bwe_updates = 19;
  total_size += 2UL * this->_internal_delay_based_bwe_updates_size();
  for (const auto& msg : this->delay_based_bwe_updates_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.AudioNetworkAdaptations audio_network_adaptations = 20;
  total_size += 2UL * this->_internal_audio_network_adaptations_size();
  for (const auto& msg : this->audio_network_adaptations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.BweProbeCluster probe_clusters = 21;
  total_size += 2UL * this->_internal_probe_clusters_size();
  for (const auto& msg : this->probe_clusters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.BweProbeResultSuccess probe_success = 22;
  total_size += 2UL * this->_internal_probe_success_size();
  for (const auto& msg : this->probe_success_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.BweProbeResultFailure probe_failure = 23;
  total_size += 2UL * this->_internal_probe_failure_size();
  for (const auto& msg : this->probe_failure_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.AlrState alr_states = 24;
  total_size += 2UL * this->_internal_alr_states_size();
  for (const auto& msg : this->alr_states_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.IceCandidatePairConfig ice_candidate_configs = 25;
  total_size += 2UL * this->_internal_ice_candidate_configs_size();
  for (const auto& msg : this->ice_candidate_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.IceCandidatePairEvent ice_candidate_events = 26;
  total_size += 2UL * this->_internal_ice_candidate_events_size();
  for (const auto& msg : this->ice_candidate_events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.DtlsTransportStateEvent dtls_transport_state_events = 27;
  total_size += 2UL * this->_internal_dtls_transport_state_events_size();
  for (const auto& msg : this->dtls_transport_state_events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.DtlsWritableState dtls_writable_states = 28;
  total_size += 2UL * this->_internal_dtls_writable_states_size();
  for (const auto& msg : this->dtls_writable_states_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.GenericPacketSent generic_packets_sent = 29;
  total_size += 2UL * this->_internal_generic_packets_sent_size();
  for (const auto& msg : this->generic_packets_sent_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.GenericPacketReceived generic_packets_received = 30;
  total_size += 2UL * this->_internal_generic_packets_received_size();
  for (const auto& msg : this->generic_packets_received_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.GenericAckReceived generic_acks_received = 31;
  total_size += 2UL * this->_internal_generic_acks_received_size();
  for (const auto& msg : this->generic_acks_received_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.RouteChange route_changes = 32;
  total_size += 2UL * this->_internal_route_changes_size();
  for (const auto& msg : this->route_changes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.RemoteEstimates remote_estimates = 33;
  total_size += 2UL * this->_internal_remote_estimates_size();
  for (const auto& msg : this->remote_estimates_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.NetEqSetMinimumDelay neteq_set_minimum_delay = 34;
  total_size += 2UL * this->_internal_neteq_set_minimum_delay_size();
  for (const auto& msg : this->neteq_set_minimum_delay_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.AudioRecvStreamConfig audio_recv_stream_configs = 101;
  total_size += 2UL * this->_internal_audio_recv_stream_configs_size();
  for (const auto& msg : this->audio_recv_stream_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.AudioSendStreamConfig audio_send_stream_configs = 102;
  total_size += 2UL * this->_internal_audio_send_stream_configs_size();
  for (const auto& msg : this->audio_send_stream_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.VideoRecvStreamConfig video_recv_stream_configs = 103;
  total_size += 2UL * this->_internal_video_recv_stream_configs_size();
  for (const auto& msg : this->video_recv_stream_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .webrtc.rtclog2.VideoSendStreamConfig video_send_stream_configs = 104;
  total_size += 2UL * this->_internal_video_send_stream_configs_size();
  for (const auto& msg : this->video_send_stream_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EventStream::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EventStream*>(
      &from));
}

void EventStream::MergeFrom(const EventStream& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.EventStream)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  stream_.MergeFrom(from.stream_);
  incoming_rtp_packets_.MergeFrom(from.incoming_rtp_packets_);
  outgoing_rtp_packets_.MergeFrom(from.outgoing_rtp_packets_);
  incoming_rtcp_packets_.MergeFrom(from.incoming_rtcp_packets_);
  outgoing_rtcp_packets_.MergeFrom(from.outgoing_rtcp_packets_);
  audio_playout_events_.MergeFrom(from.audio_playout_events_);
  frame_decoded_events_.MergeFrom(from.frame_decoded_events_);
  begin_log_events_.MergeFrom(from.begin_log_events_);
  end_log_events_.MergeFrom(from.end_log_events_);
  loss_based_bwe_updates_.MergeFrom(from.loss_based_bwe_updates_);
  delay_based_bwe_updates_.MergeFrom(from.delay_based_bwe_updates_);
  audio_network_adaptations_.MergeFrom(from.audio_network_adaptations_);
  probe_clusters_.MergeFrom(from.probe_clusters_);
  probe_success_.MergeFrom(from.probe_success_);
  probe_failure_.MergeFrom(from.probe_failure_);
  alr_states_.MergeFrom(from.alr_states_);
  ice_candidate_configs_.MergeFrom(from.ice_candidate_configs_);
  ice_candidate_events_.MergeFrom(from.ice_candidate_events_);
  dtls_transport_state_events_.MergeFrom(from.dtls_transport_state_events_);
  dtls_writable_states_.MergeFrom(from.dtls_writable_states_);
  generic_packets_sent_.MergeFrom(from.generic_packets_sent_);
  generic_packets_received_.MergeFrom(from.generic_packets_received_);
  generic_acks_received_.MergeFrom(from.generic_acks_received_);
  route_changes_.MergeFrom(from.route_changes_);
  remote_estimates_.MergeFrom(from.remote_estimates_);
  neteq_set_minimum_delay_.MergeFrom(from.neteq_set_minimum_delay_);
  audio_recv_stream_configs_.MergeFrom(from.audio_recv_stream_configs_);
  audio_send_stream_configs_.MergeFrom(from.audio_send_stream_configs_);
  video_recv_stream_configs_.MergeFrom(from.video_recv_stream_configs_);
  video_send_stream_configs_.MergeFrom(from.video_send_stream_configs_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventStream::CopyFrom(const EventStream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.EventStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventStream::IsInitialized() const {
  return true;
}

void EventStream::InternalSwap(EventStream* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  stream_.InternalSwap(&other->stream_);
  incoming_rtp_packets_.InternalSwap(&other->incoming_rtp_packets_);
  outgoing_rtp_packets_.InternalSwap(&other->outgoing_rtp_packets_);
  incoming_rtcp_packets_.InternalSwap(&other->incoming_rtcp_packets_);
  outgoing_rtcp_packets_.InternalSwap(&other->outgoing_rtcp_packets_);
  audio_playout_events_.InternalSwap(&other->audio_playout_events_);
  frame_decoded_events_.InternalSwap(&other->frame_decoded_events_);
  begin_log_events_.InternalSwap(&other->begin_log_events_);
  end_log_events_.InternalSwap(&other->end_log_events_);
  loss_based_bwe_updates_.InternalSwap(&other->loss_based_bwe_updates_);
  delay_based_bwe_updates_.InternalSwap(&other->delay_based_bwe_updates_);
  audio_network_adaptations_.InternalSwap(&other->audio_network_adaptations_);
  probe_clusters_.InternalSwap(&other->probe_clusters_);
  probe_success_.InternalSwap(&other->probe_success_);
  probe_failure_.InternalSwap(&other->probe_failure_);
  alr_states_.InternalSwap(&other->alr_states_);
  ice_candidate_configs_.InternalSwap(&other->ice_candidate_configs_);
  ice_candidate_events_.InternalSwap(&other->ice_candidate_events_);
  dtls_transport_state_events_.InternalSwap(&other->dtls_transport_state_events_);
  dtls_writable_states_.InternalSwap(&other->dtls_writable_states_);
  generic_packets_sent_.InternalSwap(&other->generic_packets_sent_);
  generic_packets_received_.InternalSwap(&other->generic_packets_received_);
  generic_acks_received_.InternalSwap(&other->generic_acks_received_);
  route_changes_.InternalSwap(&other->route_changes_);
  remote_estimates_.InternalSwap(&other->remote_estimates_);
  neteq_set_minimum_delay_.InternalSwap(&other->neteq_set_minimum_delay_);
  audio_recv_stream_configs_.InternalSwap(&other->audio_recv_stream_configs_);
  audio_send_stream_configs_.InternalSwap(&other->audio_send_stream_configs_);
  video_recv_stream_configs_.InternalSwap(&other->video_recv_stream_configs_);
  video_send_stream_configs_.InternalSwap(&other->video_send_stream_configs_);
}

std::string EventStream::GetTypeName() const {
  return "webrtc.rtclog2.EventStream";
}


// ===================================================================

class Event::_Internal {
 public:
};

Event::Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.Event)
}
Event::Event(const Event& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.Event)
}

inline void Event::SharedCtor() {
}

Event::~Event() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.Event)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Event::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Event::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Event::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.Event)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* Event::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Event::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.Event)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.Event)
  return target;
}

size_t Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.Event)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Event::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Event*>(
      &from));
}

void Event::MergeFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.Event)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Event::CopyFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  return true;
}

void Event::InternalSwap(Event* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string Event::GetTypeName() const {
  return "webrtc.rtclog2.Event";
}


// ===================================================================

class GenericPacketReceived::_Internal {
 public:
  using HasBits = decltype(std::declval<GenericPacketReceived>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_packet_number(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_packet_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_packet_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_packet_length_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GenericPacketReceived::GenericPacketReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.GenericPacketReceived)
}
GenericPacketReceived::GenericPacketReceived(const GenericPacketReceived& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  packet_number_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    packet_number_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_packet_number_deltas()) {
    packet_number_deltas_.Set(from._internal_packet_number_deltas(), 
      GetArenaForAllocation());
  }
  packet_length_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    packet_length_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_packet_length_deltas()) {
    packet_length_deltas_.Set(from._internal_packet_length_deltas(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.GenericPacketReceived)
}

inline void GenericPacketReceived::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
packet_number_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  packet_number_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
packet_length_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  packet_length_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

GenericPacketReceived::~GenericPacketReceived() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.GenericPacketReceived)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GenericPacketReceived::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  packet_number_deltas_.Destroy();
  packet_length_deltas_.Destroy();
}

void GenericPacketReceived::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenericPacketReceived::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.GenericPacketReceived)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      packet_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      packet_length_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_deltas_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GenericPacketReceived::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 packet_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_packet_number(&has_bits);
          packet_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 packet_length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_packet_length(&has_bits);
          packet_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes packet_number_deltas = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_packet_number_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes packet_length_deltas = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_packet_length_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GenericPacketReceived::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.GenericPacketReceived)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional int64 packet_number = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_packet_number(), target);
  }

  // optional int32 packet_length = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_packet_length(), target);
  }

  // optional uint32 number_of_deltas = 16;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 17;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        17, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes packet_number_deltas = 18;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        18, this->_internal_packet_number_deltas(), target);
  }

  // optional bytes packet_length_deltas = 19;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        19, this->_internal_packet_length_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.GenericPacketReceived)
  return target;
}

size_t GenericPacketReceived::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.GenericPacketReceived)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes timestamp_ms_deltas = 17;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes packet_number_deltas = 18;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_packet_number_deltas());
    }

    // optional bytes packet_length_deltas = 19;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_packet_length_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional int64 packet_number = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_packet_number());
    }

    // optional int32 packet_length = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_packet_length());
    }

    // optional uint32 number_of_deltas = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GenericPacketReceived::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GenericPacketReceived*>(
      &from));
}

void GenericPacketReceived::MergeFrom(const GenericPacketReceived& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.GenericPacketReceived)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_packet_number_deltas(from._internal_packet_number_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_packet_length_deltas(from._internal_packet_length_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      packet_number_ = from.packet_number_;
    }
    if (cached_has_bits & 0x00000020u) {
      packet_length_ = from.packet_length_;
    }
    if (cached_has_bits & 0x00000040u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GenericPacketReceived::CopyFrom(const GenericPacketReceived& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.GenericPacketReceived)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenericPacketReceived::IsInitialized() const {
  return true;
}

void GenericPacketReceived::InternalSwap(GenericPacketReceived* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &packet_number_deltas_, lhs_arena,
      &other->packet_number_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &packet_length_deltas_, lhs_arena,
      &other->packet_length_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenericPacketReceived, number_of_deltas_)
      + sizeof(GenericPacketReceived::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(GenericPacketReceived, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string GenericPacketReceived::GetTypeName() const {
  return "webrtc.rtclog2.GenericPacketReceived";
}


// ===================================================================

class GenericPacketSent::_Internal {
 public:
  using HasBits = decltype(std::declval<GenericPacketSent>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_packet_number(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_overhead_length(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_payload_length(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_padding_length(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_packet_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_overhead_length_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_payload_length_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_padding_length_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

GenericPacketSent::GenericPacketSent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.GenericPacketSent)
}
GenericPacketSent::GenericPacketSent(const GenericPacketSent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  packet_number_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    packet_number_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_packet_number_deltas()) {
    packet_number_deltas_.Set(from._internal_packet_number_deltas(), 
      GetArenaForAllocation());
  }
  overhead_length_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    overhead_length_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_overhead_length_deltas()) {
    overhead_length_deltas_.Set(from._internal_overhead_length_deltas(), 
      GetArenaForAllocation());
  }
  payload_length_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    payload_length_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload_length_deltas()) {
    payload_length_deltas_.Set(from._internal_payload_length_deltas(), 
      GetArenaForAllocation());
  }
  padding_length_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    padding_length_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_padding_length_deltas()) {
    padding_length_deltas_.Set(from._internal_padding_length_deltas(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.GenericPacketSent)
}

inline void GenericPacketSent::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
packet_number_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  packet_number_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
overhead_length_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  overhead_length_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
payload_length_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  payload_length_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
padding_length_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  padding_length_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

GenericPacketSent::~GenericPacketSent() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.GenericPacketSent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GenericPacketSent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  packet_number_deltas_.Destroy();
  overhead_length_deltas_.Destroy();
  payload_length_deltas_.Destroy();
  padding_length_deltas_.Destroy();
}

void GenericPacketSent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenericPacketSent::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.GenericPacketSent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      packet_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      overhead_length_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      payload_length_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      padding_length_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&overhead_length_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(overhead_length_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&payload_length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_deltas_) -
        reinterpret_cast<char*>(&payload_length_)) + sizeof(number_of_deltas_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GenericPacketSent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 packet_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_packet_number(&has_bits);
          packet_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 overhead_length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_overhead_length(&has_bits);
          overhead_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 payload_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_payload_length(&has_bits);
          payload_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 padding_length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_padding_length(&has_bits);
          padding_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes packet_number_deltas = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_packet_number_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes overhead_length_deltas = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_overhead_length_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payload_length_deltas = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_payload_length_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes padding_length_deltas = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_padding_length_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GenericPacketSent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.GenericPacketSent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional int64 packet_number = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_packet_number(), target);
  }

  // optional int32 overhead_length = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_overhead_length(), target);
  }

  // optional int32 payload_length = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_payload_length(), target);
  }

  // optional int32 padding_length = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_padding_length(), target);
  }

  // optional uint32 number_of_deltas = 16;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 17;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        17, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes packet_number_deltas = 18;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        18, this->_internal_packet_number_deltas(), target);
  }

  // optional bytes overhead_length_deltas = 19;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        19, this->_internal_overhead_length_deltas(), target);
  }

  // optional bytes payload_length_deltas = 20;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_payload_length_deltas(), target);
  }

  // optional bytes padding_length_deltas = 21;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        21, this->_internal_padding_length_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.GenericPacketSent)
  return target;
}

size_t GenericPacketSent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.GenericPacketSent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 17;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes packet_number_deltas = 18;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_packet_number_deltas());
    }

    // optional bytes overhead_length_deltas = 19;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_overhead_length_deltas());
    }

    // optional bytes payload_length_deltas = 20;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload_length_deltas());
    }

    // optional bytes padding_length_deltas = 21;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_padding_length_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional int64 packet_number = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_packet_number());
    }

    // optional int32 overhead_length = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_overhead_length());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional int32 payload_length = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_payload_length());
    }

    // optional int32 padding_length = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_padding_length());
    }

    // optional uint32 number_of_deltas = 16;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GenericPacketSent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GenericPacketSent*>(
      &from));
}

void GenericPacketSent::MergeFrom(const GenericPacketSent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.GenericPacketSent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_packet_number_deltas(from._internal_packet_number_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_overhead_length_deltas(from._internal_overhead_length_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_payload_length_deltas(from._internal_payload_length_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_padding_length_deltas(from._internal_padding_length_deltas());
    }
    if (cached_has_bits & 0x00000020u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      packet_number_ = from.packet_number_;
    }
    if (cached_has_bits & 0x00000080u) {
      overhead_length_ = from.overhead_length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      payload_length_ = from.payload_length_;
    }
    if (cached_has_bits & 0x00000200u) {
      padding_length_ = from.padding_length_;
    }
    if (cached_has_bits & 0x00000400u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GenericPacketSent::CopyFrom(const GenericPacketSent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.GenericPacketSent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenericPacketSent::IsInitialized() const {
  return true;
}

void GenericPacketSent::InternalSwap(GenericPacketSent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &packet_number_deltas_, lhs_arena,
      &other->packet_number_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &overhead_length_deltas_, lhs_arena,
      &other->overhead_length_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &payload_length_deltas_, lhs_arena,
      &other->payload_length_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &padding_length_deltas_, lhs_arena,
      &other->padding_length_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenericPacketSent, number_of_deltas_)
      + sizeof(GenericPacketSent::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(GenericPacketSent, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string GenericPacketSent::GetTypeName() const {
  return "webrtc.rtclog2.GenericPacketSent";
}


// ===================================================================

class GenericAckReceived::_Internal {
 public:
  using HasBits = decltype(std::declval<GenericAckReceived>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_packet_number(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_acked_packet_number(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_receive_acked_packet_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_packet_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_acked_packet_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_receive_acked_packet_time_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

GenericAckReceived::GenericAckReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.GenericAckReceived)
}
GenericAckReceived::GenericAckReceived(const GenericAckReceived& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  packet_number_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    packet_number_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_packet_number_deltas()) {
    packet_number_deltas_.Set(from._internal_packet_number_deltas(), 
      GetArenaForAllocation());
  }
  acked_packet_number_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    acked_packet_number_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_acked_packet_number_deltas()) {
    acked_packet_number_deltas_.Set(from._internal_acked_packet_number_deltas(), 
      GetArenaForAllocation());
  }
  receive_acked_packet_time_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    receive_acked_packet_time_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_receive_acked_packet_time_ms_deltas()) {
    receive_acked_packet_time_ms_deltas_.Set(from._internal_receive_acked_packet_time_ms_deltas(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.GenericAckReceived)
}

inline void GenericAckReceived::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
packet_number_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  packet_number_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
acked_packet_number_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  acked_packet_number_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
receive_acked_packet_time_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  receive_acked_packet_time_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

GenericAckReceived::~GenericAckReceived() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.GenericAckReceived)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GenericAckReceived::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  packet_number_deltas_.Destroy();
  acked_packet_number_deltas_.Destroy();
  receive_acked_packet_time_ms_deltas_.Destroy();
}

void GenericAckReceived::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenericAckReceived::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.GenericAckReceived)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      packet_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      acked_packet_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      receive_acked_packet_time_ms_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&receive_acked_packet_time_ms_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(receive_acked_packet_time_ms_));
  }
  number_of_deltas_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GenericAckReceived::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 packet_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_packet_number(&has_bits);
          packet_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 acked_packet_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_acked_packet_number(&has_bits);
          acked_packet_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 receive_acked_packet_time_ms = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_receive_acked_packet_time_ms(&has_bits);
          receive_acked_packet_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes packet_number_deltas = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_packet_number_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes acked_packet_number_deltas = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_acked_packet_number_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes receive_acked_packet_time_ms_deltas = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_receive_acked_packet_time_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GenericAckReceived::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.GenericAckReceived)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional int64 packet_number = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_packet_number(), target);
  }

  // optional int64 acked_packet_number = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_acked_packet_number(), target);
  }

  // optional int64 receive_acked_packet_time_ms = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_receive_acked_packet_time_ms(), target);
  }

  // optional uint32 number_of_deltas = 16;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 17;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        17, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes packet_number_deltas = 18;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        18, this->_internal_packet_number_deltas(), target);
  }

  // optional bytes acked_packet_number_deltas = 19;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        19, this->_internal_acked_packet_number_deltas(), target);
  }

  // optional bytes receive_acked_packet_time_ms_deltas = 20;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_receive_acked_packet_time_ms_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.GenericAckReceived)
  return target;
}

size_t GenericAckReceived::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.GenericAckReceived)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 17;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes packet_number_deltas = 18;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_packet_number_deltas());
    }

    // optional bytes acked_packet_number_deltas = 19;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_acked_packet_number_deltas());
    }

    // optional bytes receive_acked_packet_time_ms_deltas = 20;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_receive_acked_packet_time_ms_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional int64 packet_number = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_packet_number());
    }

    // optional int64 acked_packet_number = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_acked_packet_number());
    }

    // optional int64 receive_acked_packet_time_ms = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_receive_acked_packet_time_ms());
    }

  }
  // optional uint32 number_of_deltas = 16;
  if (cached_has_bits & 0x00000100u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_number_of_deltas());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GenericAckReceived::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GenericAckReceived*>(
      &from));
}

void GenericAckReceived::MergeFrom(const GenericAckReceived& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.GenericAckReceived)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_packet_number_deltas(from._internal_packet_number_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_acked_packet_number_deltas(from._internal_acked_packet_number_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_receive_acked_packet_time_ms_deltas(from._internal_receive_acked_packet_time_ms_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000020u) {
      packet_number_ = from.packet_number_;
    }
    if (cached_has_bits & 0x00000040u) {
      acked_packet_number_ = from.acked_packet_number_;
    }
    if (cached_has_bits & 0x00000080u) {
      receive_acked_packet_time_ms_ = from.receive_acked_packet_time_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_number_of_deltas(from._internal_number_of_deltas());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GenericAckReceived::CopyFrom(const GenericAckReceived& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.GenericAckReceived)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenericAckReceived::IsInitialized() const {
  return true;
}

void GenericAckReceived::InternalSwap(GenericAckReceived* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &packet_number_deltas_, lhs_arena,
      &other->packet_number_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &acked_packet_number_deltas_, lhs_arena,
      &other->acked_packet_number_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &receive_acked_packet_time_ms_deltas_, lhs_arena,
      &other->receive_acked_packet_time_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenericAckReceived, number_of_deltas_)
      + sizeof(GenericAckReceived::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(GenericAckReceived, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string GenericAckReceived::GetTypeName() const {
  return "webrtc.rtclog2.GenericAckReceived";
}


// ===================================================================

class DependencyDescriptorsWireInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DependencyDescriptorsWireInfo>()._has_bits_);
  static void set_has_start_end_bit(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_start_end_bit_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_template_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_template_id_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_frame_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_frame_id_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_extended_infos(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DependencyDescriptorsWireInfo::DependencyDescriptorsWireInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.DependencyDescriptorsWireInfo)
}
DependencyDescriptorsWireInfo::DependencyDescriptorsWireInfo(const DependencyDescriptorsWireInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  start_end_bit_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    start_end_bit_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_start_end_bit_deltas()) {
    start_end_bit_deltas_.Set(from._internal_start_end_bit_deltas(), 
      GetArenaForAllocation());
  }
  template_id_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    template_id_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_template_id_deltas()) {
    template_id_deltas_.Set(from._internal_template_id_deltas(), 
      GetArenaForAllocation());
  }
  frame_id_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    frame_id_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_frame_id_deltas()) {
    frame_id_deltas_.Set(from._internal_frame_id_deltas(), 
      GetArenaForAllocation());
  }
  extended_infos_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    extended_infos_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extended_infos()) {
    extended_infos_.Set(from._internal_extended_infos(), 
      GetArenaForAllocation());
  }
  ::memcpy(&start_end_bit_, &from.start_end_bit_,
    static_cast<size_t>(reinterpret_cast<char*>(&frame_id_) -
    reinterpret_cast<char*>(&start_end_bit_)) + sizeof(frame_id_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.DependencyDescriptorsWireInfo)
}

inline void DependencyDescriptorsWireInfo::SharedCtor() {
start_end_bit_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  start_end_bit_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
template_id_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  template_id_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
frame_id_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  frame_id_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
extended_infos_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  extended_infos_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_end_bit_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frame_id_) -
    reinterpret_cast<char*>(&start_end_bit_)) + sizeof(frame_id_));
}

DependencyDescriptorsWireInfo::~DependencyDescriptorsWireInfo() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DependencyDescriptorsWireInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  start_end_bit_deltas_.Destroy();
  template_id_deltas_.Destroy();
  frame_id_deltas_.Destroy();
  extended_infos_.Destroy();
}

void DependencyDescriptorsWireInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DependencyDescriptorsWireInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      start_end_bit_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      template_id_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      frame_id_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      extended_infos_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&start_end_bit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&frame_id_) -
        reinterpret_cast<char*>(&start_end_bit_)) + sizeof(frame_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DependencyDescriptorsWireInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 start_end_bit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_start_end_bit(&has_bits);
          start_end_bit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes start_end_bit_deltas = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_start_end_bit_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 template_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_template_id(&has_bits);
          template_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes template_id_deltas = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_template_id_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 frame_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_frame_id(&has_bits);
          frame_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes frame_id_deltas = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_frame_id_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes extended_infos = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_extended_infos();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DependencyDescriptorsWireInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 start_end_bit = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_start_end_bit(), target);
  }

  // optional bytes start_end_bit_deltas = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_start_end_bit_deltas(), target);
  }

  // optional uint32 template_id = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_template_id(), target);
  }

  // optional bytes template_id_deltas = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_template_id_deltas(), target);
  }

  // optional uint32 frame_id = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_frame_id(), target);
  }

  // optional bytes frame_id_deltas = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_frame_id_deltas(), target);
  }

  // optional bytes extended_infos = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_extended_infos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  return target;
}

size_t DependencyDescriptorsWireInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes start_end_bit_deltas = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_start_end_bit_deltas());
    }

    // optional bytes template_id_deltas = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_template_id_deltas());
    }

    // optional bytes frame_id_deltas = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_frame_id_deltas());
    }

    // optional bytes extended_infos = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_extended_infos());
    }

    // optional uint32 start_end_bit = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_end_bit());
    }

    // optional uint32 template_id = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_template_id());
    }

    // optional uint32 frame_id = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DependencyDescriptorsWireInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DependencyDescriptorsWireInfo*>(
      &from));
}

void DependencyDescriptorsWireInfo::MergeFrom(const DependencyDescriptorsWireInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_start_end_bit_deltas(from._internal_start_end_bit_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_template_id_deltas(from._internal_template_id_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_frame_id_deltas(from._internal_frame_id_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_extended_infos(from._internal_extended_infos());
    }
    if (cached_has_bits & 0x00000010u) {
      start_end_bit_ = from.start_end_bit_;
    }
    if (cached_has_bits & 0x00000020u) {
      template_id_ = from.template_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      frame_id_ = from.frame_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DependencyDescriptorsWireInfo::CopyFrom(const DependencyDescriptorsWireInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DependencyDescriptorsWireInfo::IsInitialized() const {
  return true;
}

void DependencyDescriptorsWireInfo::InternalSwap(DependencyDescriptorsWireInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &start_end_bit_deltas_, lhs_arena,
      &other->start_end_bit_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &template_id_deltas_, lhs_arena,
      &other->template_id_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &frame_id_deltas_, lhs_arena,
      &other->frame_id_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &extended_infos_, lhs_arena,
      &other->extended_infos_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, frame_id_)
      + sizeof(DependencyDescriptorsWireInfo::frame_id_)
      - PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, start_end_bit_)>(
          reinterpret_cast<char*>(&start_end_bit_),
          reinterpret_cast<char*>(&other->start_end_bit_));
}

std::string DependencyDescriptorsWireInfo::GetTypeName() const {
  return "webrtc.rtclog2.DependencyDescriptorsWireInfo";
}


// ===================================================================

class IncomingRtpPackets::_Internal {
 public:
  using HasBits = decltype(std::declval<IncomingRtpPackets>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_marker(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_payload_type(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_sequence_number(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_rtp_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_payload_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_header_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_padding_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_transport_sequence_number(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_transmission_time_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_absolute_send_time(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_video_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_audio_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_voice_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& dependency_descriptor(const IncomingRtpPackets* msg);
  static void set_has_dependency_descriptor(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_marker_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_payload_type_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sequence_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rtp_timestamp_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ssrc_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_payload_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_header_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_padding_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_transport_sequence_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_transmission_time_offset_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_absolute_send_time_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_video_rotation_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_audio_level_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_voice_activity_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

const ::webrtc::rtclog2::DependencyDescriptorsWireInfo&
IncomingRtpPackets::_Internal::dependency_descriptor(const IncomingRtpPackets* msg) {
  return *msg->dependency_descriptor_;
}
IncomingRtpPackets::IncomingRtpPackets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.IncomingRtpPackets)
}
IncomingRtpPackets::IncomingRtpPackets(const IncomingRtpPackets& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  marker_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    marker_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_marker_deltas()) {
    marker_deltas_.Set(from._internal_marker_deltas(), 
      GetArenaForAllocation());
  }
  payload_type_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    payload_type_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload_type_deltas()) {
    payload_type_deltas_.Set(from._internal_payload_type_deltas(), 
      GetArenaForAllocation());
  }
  sequence_number_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sequence_number_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sequence_number_deltas()) {
    sequence_number_deltas_.Set(from._internal_sequence_number_deltas(), 
      GetArenaForAllocation());
  }
  rtp_timestamp_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    rtp_timestamp_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rtp_timestamp_deltas()) {
    rtp_timestamp_deltas_.Set(from._internal_rtp_timestamp_deltas(), 
      GetArenaForAllocation());
  }
  ssrc_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ssrc_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ssrc_deltas()) {
    ssrc_deltas_.Set(from._internal_ssrc_deltas(), 
      GetArenaForAllocation());
  }
  payload_size_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    payload_size_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload_size_deltas()) {
    payload_size_deltas_.Set(from._internal_payload_size_deltas(), 
      GetArenaForAllocation());
  }
  header_size_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    header_size_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_header_size_deltas()) {
    header_size_deltas_.Set(from._internal_header_size_deltas(), 
      GetArenaForAllocation());
  }
  padding_size_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    padding_size_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_padding_size_deltas()) {
    padding_size_deltas_.Set(from._internal_padding_size_deltas(), 
      GetArenaForAllocation());
  }
  transport_sequence_number_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    transport_sequence_number_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_transport_sequence_number_deltas()) {
    transport_sequence_number_deltas_.Set(from._internal_transport_sequence_number_deltas(), 
      GetArenaForAllocation());
  }
  transmission_time_offset_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    transmission_time_offset_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_transmission_time_offset_deltas()) {
    transmission_time_offset_deltas_.Set(from._internal_transmission_time_offset_deltas(), 
      GetArenaForAllocation());
  }
  absolute_send_time_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    absolute_send_time_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_absolute_send_time_deltas()) {
    absolute_send_time_deltas_.Set(from._internal_absolute_send_time_deltas(), 
      GetArenaForAllocation());
  }
  video_rotation_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    video_rotation_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_video_rotation_deltas()) {
    video_rotation_deltas_.Set(from._internal_video_rotation_deltas(), 
      GetArenaForAllocation());
  }
  audio_level_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    audio_level_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_audio_level_deltas()) {
    audio_level_deltas_.Set(from._internal_audio_level_deltas(), 
      GetArenaForAllocation());
  }
  voice_activity_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    voice_activity_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_voice_activity_deltas()) {
    voice_activity_deltas_.Set(from._internal_voice_activity_deltas(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_dependency_descriptor()) {
    dependency_descriptor_ = new ::webrtc::rtclog2::DependencyDescriptorsWireInfo(*from.dependency_descriptor_);
  } else {
    dependency_descriptor_ = nullptr;
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&audio_level_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(audio_level_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.IncomingRtpPackets)
}

inline void IncomingRtpPackets::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
marker_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  marker_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
payload_type_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  payload_type_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sequence_number_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sequence_number_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
rtp_timestamp_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  rtp_timestamp_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ssrc_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ssrc_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
payload_size_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  payload_size_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
header_size_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  header_size_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
padding_size_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  padding_size_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
transport_sequence_number_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  transport_sequence_number_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
transmission_time_offset_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  transmission_time_offset_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
absolute_send_time_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  absolute_send_time_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
video_rotation_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  video_rotation_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
audio_level_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  audio_level_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
voice_activity_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  voice_activity_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dependency_descriptor_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&audio_level_) -
    reinterpret_cast<char*>(&dependency_descriptor_)) + sizeof(audio_level_));
}

IncomingRtpPackets::~IncomingRtpPackets() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.IncomingRtpPackets)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IncomingRtpPackets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  marker_deltas_.Destroy();
  payload_type_deltas_.Destroy();
  sequence_number_deltas_.Destroy();
  rtp_timestamp_deltas_.Destroy();
  ssrc_deltas_.Destroy();
  payload_size_deltas_.Destroy();
  header_size_deltas_.Destroy();
  padding_size_deltas_.Destroy();
  transport_sequence_number_deltas_.Destroy();
  transmission_time_offset_deltas_.Destroy();
  absolute_send_time_deltas_.Destroy();
  video_rotation_deltas_.Destroy();
  audio_level_deltas_.Destroy();
  voice_activity_deltas_.Destroy();
  if (this != internal_default_instance()) delete dependency_descriptor_;
}

void IncomingRtpPackets::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IncomingRtpPackets::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.IncomingRtpPackets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      marker_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      payload_type_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      sequence_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      rtp_timestamp_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      ssrc_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      payload_size_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      header_size_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      padding_size_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      transport_sequence_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      transmission_time_offset_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      absolute_send_time_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00001000u) {
      video_rotation_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00002000u) {
      audio_level_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00004000u) {
      voice_activity_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(dependency_descriptor_ != nullptr);
      dependency_descriptor_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&padding_size_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(padding_size_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&number_of_deltas_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&audio_level_) -
        reinterpret_cast<char*>(&number_of_deltas_)) + sizeof(audio_level_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IncomingRtpPackets::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool marker = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_marker(&has_bits);
          marker_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 payload_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_payload_type(&has_bits);
          payload_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sequence_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sequence_number(&has_bits);
          sequence_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 rtp_timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_rtp_timestamp(&has_bits);
          rtp_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 ssrc = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_ssrc(&has_bits);
          ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 payload_size = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_payload_size(&has_bits);
          payload_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 header_size = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_header_size(&has_bits);
          header_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 padding_size = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_padding_size(&has_bits);
          padding_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 transport_sequence_number = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_transport_sequence_number(&has_bits);
          transport_sequence_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 transmission_time_offset = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_transmission_time_offset(&has_bits);
          transmission_time_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 absolute_send_time = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_absolute_send_time(&has_bits);
          absolute_send_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 video_rotation = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_video_rotation(&has_bits);
          video_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 audio_level = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_audio_level(&has_bits);
          audio_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool voice_activity = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_voice_activity(&has_bits);
          voice_activity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_dependency_descriptor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes marker_deltas = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_marker_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payload_type_deltas = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_payload_type_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes sequence_number_deltas = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_sequence_number_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes rtp_timestamp_deltas = 105;
      case 105:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_rtp_timestamp_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ssrc_deltas = 106;
      case 106:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_ssrc_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payload_size_deltas = 108;
      case 108:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_payload_size_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes header_size_deltas = 109;
      case 109:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_header_size_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes padding_size_deltas = 110;
      case 110:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_padding_size_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes transport_sequence_number_deltas = 115;
      case 115:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_transport_sequence_number_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes transmission_time_offset_deltas = 116;
      case 116:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_transmission_time_offset_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes absolute_send_time_deltas = 117;
      case 117:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_absolute_send_time_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes video_rotation_deltas = 118;
      case 118:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_video_rotation_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes audio_level_deltas = 119;
      case 119:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_audio_level_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes voice_activity_deltas = 120;
      case 120:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          auto str = _internal_mutable_voice_activity_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IncomingRtpPackets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.IncomingRtpPackets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional bool marker = 2;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_marker(), target);
  }

  // optional uint32 payload_type = 3;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_payload_type(), target);
  }

  // optional uint32 sequence_number = 4;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_sequence_number(), target);
  }

  // optional fixed32 rtp_timestamp = 5;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_rtp_timestamp(), target);
  }

  // optional fixed32 ssrc = 6;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_ssrc(), target);
  }

  // optional uint32 payload_size = 8;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_payload_size(), target);
  }

  // optional uint32 header_size = 9;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_header_size(), target);
  }

  // optional uint32 padding_size = 10;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_padding_size(), target);
  }

  // optional uint32 number_of_deltas = 11;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_number_of_deltas(), target);
  }

  // optional uint32 transport_sequence_number = 15;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_transport_sequence_number(), target);
  }

  // optional int32 transmission_time_offset = 16;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_transmission_time_offset(), target);
  }

  // optional uint32 absolute_send_time = 17;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_absolute_send_time(), target);
  }

  // optional uint32 video_rotation = 18;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_video_rotation(), target);
  }

  // optional uint32 audio_level = 19;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_audio_level(), target);
  }

  // optional bool voice_activity = 20;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_voice_activity(), target);
  }

  // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::dependency_descriptor(this),
        _Internal::dependency_descriptor(this).GetCachedSize(), target, stream);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        101, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes marker_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        102, this->_internal_marker_deltas(), target);
  }

  // optional bytes payload_type_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        103, this->_internal_payload_type_deltas(), target);
  }

  // optional bytes sequence_number_deltas = 104;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        104, this->_internal_sequence_number_deltas(), target);
  }

  // optional bytes rtp_timestamp_deltas = 105;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        105, this->_internal_rtp_timestamp_deltas(), target);
  }

  // optional bytes ssrc_deltas = 106;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        106, this->_internal_ssrc_deltas(), target);
  }

  // optional bytes payload_size_deltas = 108;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        108, this->_internal_payload_size_deltas(), target);
  }

  // optional bytes header_size_deltas = 109;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteBytesMaybeAliased(
        109, this->_internal_header_size_deltas(), target);
  }

  // optional bytes padding_size_deltas = 110;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteBytesMaybeAliased(
        110, this->_internal_padding_size_deltas(), target);
  }

  // optional bytes transport_sequence_number_deltas = 115;
  if (cached_has_bits & 0x00000200u) {
    target = stream->WriteBytesMaybeAliased(
        115, this->_internal_transport_sequence_number_deltas(), target);
  }

  // optional bytes transmission_time_offset_deltas = 116;
  if (cached_has_bits & 0x00000400u) {
    target = stream->WriteBytesMaybeAliased(
        116, this->_internal_transmission_time_offset_deltas(), target);
  }

  // optional bytes absolute_send_time_deltas = 117;
  if (cached_has_bits & 0x00000800u) {
    target = stream->WriteBytesMaybeAliased(
        117, this->_internal_absolute_send_time_deltas(), target);
  }

  // optional bytes video_rotation_deltas = 118;
  if (cached_has_bits & 0x00001000u) {
    target = stream->WriteBytesMaybeAliased(
        118, this->_internal_video_rotation_deltas(), target);
  }

  // optional bytes audio_level_deltas = 119;
  if (cached_has_bits & 0x00002000u) {
    target = stream->WriteBytesMaybeAliased(
        119, this->_internal_audio_level_deltas(), target);
  }

  // optional bytes voice_activity_deltas = 120;
  if (cached_has_bits & 0x00004000u) {
    target = stream->WriteBytesMaybeAliased(
        120, this->_internal_voice_activity_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.IncomingRtpPackets)
  return target;
}

size_t IncomingRtpPackets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.IncomingRtpPackets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes marker_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_marker_deltas());
    }

    // optional bytes payload_type_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload_type_deltas());
    }

    // optional bytes sequence_number_deltas = 104;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_sequence_number_deltas());
    }

    // optional bytes rtp_timestamp_deltas = 105;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_rtp_timestamp_deltas());
    }

    // optional bytes ssrc_deltas = 106;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ssrc_deltas());
    }

    // optional bytes payload_size_deltas = 108;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload_size_deltas());
    }

    // optional bytes header_size_deltas = 109;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_header_size_deltas());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bytes padding_size_deltas = 110;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_padding_size_deltas());
    }

    // optional bytes transport_sequence_number_deltas = 115;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_transport_sequence_number_deltas());
    }

    // optional bytes transmission_time_offset_deltas = 116;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_transmission_time_offset_deltas());
    }

    // optional bytes absolute_send_time_deltas = 117;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_absolute_send_time_deltas());
    }

    // optional bytes video_rotation_deltas = 118;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_video_rotation_deltas());
    }

    // optional bytes audio_level_deltas = 119;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_audio_level_deltas());
    }

    // optional bytes voice_activity_deltas = 120;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_voice_activity_deltas());
    }

    // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dependency_descriptor_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 payload_type = 3;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_payload_type());
    }

    // optional uint32 sequence_number = 4;
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sequence_number());
    }

    // optional fixed32 rtp_timestamp = 5;
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 4;
    }

    // optional fixed32 ssrc = 6;
    if (cached_has_bits & 0x00100000u) {
      total_size += 1 + 4;
    }

    // optional uint32 payload_size = 8;
    if (cached_has_bits & 0x00200000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_payload_size());
    }

    // optional uint32 header_size = 9;
    if (cached_has_bits & 0x00400000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_header_size());
    }

    // optional uint32 padding_size = 10;
    if (cached_has_bits & 0x00800000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_padding_size());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 number_of_deltas = 11;
    if (cached_has_bits & 0x01000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_deltas());
    }

    // optional bool marker = 2;
    if (cached_has_bits & 0x02000000u) {
      total_size += 1 + 1;
    }

    // optional bool voice_activity = 20;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional uint32 transport_sequence_number = 15;
    if (cached_has_bits & 0x08000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_transport_sequence_number());
    }

    // optional int32 transmission_time_offset = 16;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_transmission_time_offset());
    }

    // optional uint32 absolute_send_time = 17;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_absolute_send_time());
    }

    // optional uint32 video_rotation = 18;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_video_rotation());
    }

    // optional uint32 audio_level = 19;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_audio_level());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IncomingRtpPackets::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IncomingRtpPackets*>(
      &from));
}

void IncomingRtpPackets::MergeFrom(const IncomingRtpPackets& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.IncomingRtpPackets)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_marker_deltas(from._internal_marker_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_payload_type_deltas(from._internal_payload_type_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_sequence_number_deltas(from._internal_sequence_number_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_rtp_timestamp_deltas(from._internal_rtp_timestamp_deltas());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_ssrc_deltas(from._internal_ssrc_deltas());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_payload_size_deltas(from._internal_payload_size_deltas());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_header_size_deltas(from._internal_header_size_deltas());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_set_padding_size_deltas(from._internal_padding_size_deltas());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_set_transport_sequence_number_deltas(from._internal_transport_sequence_number_deltas());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_set_transmission_time_offset_deltas(from._internal_transmission_time_offset_deltas());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_set_absolute_send_time_deltas(from._internal_absolute_send_time_deltas());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_set_video_rotation_deltas(from._internal_video_rotation_deltas());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_set_audio_level_deltas(from._internal_audio_level_deltas());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_set_voice_activity_deltas(from._internal_voice_activity_deltas());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_dependency_descriptor()->::webrtc::rtclog2::DependencyDescriptorsWireInfo::MergeFrom(from._internal_dependency_descriptor());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00020000u) {
      payload_type_ = from.payload_type_;
    }
    if (cached_has_bits & 0x00040000u) {
      sequence_number_ = from.sequence_number_;
    }
    if (cached_has_bits & 0x00080000u) {
      rtp_timestamp_ = from.rtp_timestamp_;
    }
    if (cached_has_bits & 0x00100000u) {
      ssrc_ = from.ssrc_;
    }
    if (cached_has_bits & 0x00200000u) {
      payload_size_ = from.payload_size_;
    }
    if (cached_has_bits & 0x00400000u) {
      header_size_ = from.header_size_;
    }
    if (cached_has_bits & 0x00800000u) {
      padding_size_ = from.padding_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    if (cached_has_bits & 0x02000000u) {
      marker_ = from.marker_;
    }
    if (cached_has_bits & 0x04000000u) {
      voice_activity_ = from.voice_activity_;
    }
    if (cached_has_bits & 0x08000000u) {
      transport_sequence_number_ = from.transport_sequence_number_;
    }
    if (cached_has_bits & 0x10000000u) {
      transmission_time_offset_ = from.transmission_time_offset_;
    }
    if (cached_has_bits & 0x20000000u) {
      absolute_send_time_ = from.absolute_send_time_;
    }
    if (cached_has_bits & 0x40000000u) {
      video_rotation_ = from.video_rotation_;
    }
    if (cached_has_bits & 0x80000000u) {
      audio_level_ = from.audio_level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IncomingRtpPackets::CopyFrom(const IncomingRtpPackets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.IncomingRtpPackets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IncomingRtpPackets::IsInitialized() const {
  return true;
}

void IncomingRtpPackets::InternalSwap(IncomingRtpPackets* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &marker_deltas_, lhs_arena,
      &other->marker_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &payload_type_deltas_, lhs_arena,
      &other->payload_type_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sequence_number_deltas_, lhs_arena,
      &other->sequence_number_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &rtp_timestamp_deltas_, lhs_arena,
      &other->rtp_timestamp_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ssrc_deltas_, lhs_arena,
      &other->ssrc_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &payload_size_deltas_, lhs_arena,
      &other->payload_size_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &header_size_deltas_, lhs_arena,
      &other->header_size_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &padding_size_deltas_, lhs_arena,
      &other->padding_size_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &transport_sequence_number_deltas_, lhs_arena,
      &other->transport_sequence_number_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &transmission_time_offset_deltas_, lhs_arena,
      &other->transmission_time_offset_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &absolute_send_time_deltas_, lhs_arena,
      &other->absolute_send_time_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &video_rotation_deltas_, lhs_arena,
      &other->video_rotation_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &audio_level_deltas_, lhs_arena,
      &other->audio_level_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &voice_activity_deltas_, lhs_arena,
      &other->voice_activity_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, audio_level_)
      + sizeof(IncomingRtpPackets::audio_level_)
      - PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, dependency_descriptor_)>(
          reinterpret_cast<char*>(&dependency_descriptor_),
          reinterpret_cast<char*>(&other->dependency_descriptor_));
}

std::string IncomingRtpPackets::GetTypeName() const {
  return "webrtc.rtclog2.IncomingRtpPackets";
}


// ===================================================================

class OutgoingRtpPackets::_Internal {
 public:
  using HasBits = decltype(std::declval<OutgoingRtpPackets>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_marker(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_payload_type(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_sequence_number(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_rtp_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_payload_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_header_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_padding_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_transport_sequence_number(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_transmission_time_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_absolute_send_time(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_video_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_audio_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_voice_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& dependency_descriptor(const OutgoingRtpPackets* msg);
  static void set_has_dependency_descriptor(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_marker_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_payload_type_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sequence_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rtp_timestamp_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ssrc_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_payload_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_header_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_padding_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_transport_sequence_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_transmission_time_offset_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_absolute_send_time_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_video_rotation_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_audio_level_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_voice_activity_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

const ::webrtc::rtclog2::DependencyDescriptorsWireInfo&
OutgoingRtpPackets::_Internal::dependency_descriptor(const OutgoingRtpPackets* msg) {
  return *msg->dependency_descriptor_;
}
OutgoingRtpPackets::OutgoingRtpPackets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.OutgoingRtpPackets)
}
OutgoingRtpPackets::OutgoingRtpPackets(const OutgoingRtpPackets& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  marker_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    marker_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_marker_deltas()) {
    marker_deltas_.Set(from._internal_marker_deltas(), 
      GetArenaForAllocation());
  }
  payload_type_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    payload_type_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload_type_deltas()) {
    payload_type_deltas_.Set(from._internal_payload_type_deltas(), 
      GetArenaForAllocation());
  }
  sequence_number_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sequence_number_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sequence_number_deltas()) {
    sequence_number_deltas_.Set(from._internal_sequence_number_deltas(), 
      GetArenaForAllocation());
  }
  rtp_timestamp_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    rtp_timestamp_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rtp_timestamp_deltas()) {
    rtp_timestamp_deltas_.Set(from._internal_rtp_timestamp_deltas(), 
      GetArenaForAllocation());
  }
  ssrc_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ssrc_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ssrc_deltas()) {
    ssrc_deltas_.Set(from._internal_ssrc_deltas(), 
      GetArenaForAllocation());
  }
  payload_size_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    payload_size_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload_size_deltas()) {
    payload_size_deltas_.Set(from._internal_payload_size_deltas(), 
      GetArenaForAllocation());
  }
  header_size_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    header_size_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_header_size_deltas()) {
    header_size_deltas_.Set(from._internal_header_size_deltas(), 
      GetArenaForAllocation());
  }
  padding_size_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    padding_size_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_padding_size_deltas()) {
    padding_size_deltas_.Set(from._internal_padding_size_deltas(), 
      GetArenaForAllocation());
  }
  transport_sequence_number_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    transport_sequence_number_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_transport_sequence_number_deltas()) {
    transport_sequence_number_deltas_.Set(from._internal_transport_sequence_number_deltas(), 
      GetArenaForAllocation());
  }
  transmission_time_offset_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    transmission_time_offset_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_transmission_time_offset_deltas()) {
    transmission_time_offset_deltas_.Set(from._internal_transmission_time_offset_deltas(), 
      GetArenaForAllocation());
  }
  absolute_send_time_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    absolute_send_time_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_absolute_send_time_deltas()) {
    absolute_send_time_deltas_.Set(from._internal_absolute_send_time_deltas(), 
      GetArenaForAllocation());
  }
  video_rotation_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    video_rotation_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_video_rotation_deltas()) {
    video_rotation_deltas_.Set(from._internal_video_rotation_deltas(), 
      GetArenaForAllocation());
  }
  audio_level_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    audio_level_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_audio_level_deltas()) {
    audio_level_deltas_.Set(from._internal_audio_level_deltas(), 
      GetArenaForAllocation());
  }
  voice_activity_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    voice_activity_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_voice_activity_deltas()) {
    voice_activity_deltas_.Set(from._internal_voice_activity_deltas(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_dependency_descriptor()) {
    dependency_descriptor_ = new ::webrtc::rtclog2::DependencyDescriptorsWireInfo(*from.dependency_descriptor_);
  } else {
    dependency_descriptor_ = nullptr;
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&audio_level_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(audio_level_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.OutgoingRtpPackets)
}

inline void OutgoingRtpPackets::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
marker_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  marker_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
payload_type_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  payload_type_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sequence_number_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sequence_number_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
rtp_timestamp_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  rtp_timestamp_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ssrc_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ssrc_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
payload_size_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  payload_size_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
header_size_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  header_size_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
padding_size_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  padding_size_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
transport_sequence_number_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  transport_sequence_number_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
transmission_time_offset_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  transmission_time_offset_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
absolute_send_time_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  absolute_send_time_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
video_rotation_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  video_rotation_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
audio_level_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  audio_level_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
voice_activity_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  voice_activity_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dependency_descriptor_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&audio_level_) -
    reinterpret_cast<char*>(&dependency_descriptor_)) + sizeof(audio_level_));
}

OutgoingRtpPackets::~OutgoingRtpPackets() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.OutgoingRtpPackets)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OutgoingRtpPackets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  marker_deltas_.Destroy();
  payload_type_deltas_.Destroy();
  sequence_number_deltas_.Destroy();
  rtp_timestamp_deltas_.Destroy();
  ssrc_deltas_.Destroy();
  payload_size_deltas_.Destroy();
  header_size_deltas_.Destroy();
  padding_size_deltas_.Destroy();
  transport_sequence_number_deltas_.Destroy();
  transmission_time_offset_deltas_.Destroy();
  absolute_send_time_deltas_.Destroy();
  video_rotation_deltas_.Destroy();
  audio_level_deltas_.Destroy();
  voice_activity_deltas_.Destroy();
  if (this != internal_default_instance()) delete dependency_descriptor_;
}

void OutgoingRtpPackets::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OutgoingRtpPackets::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.OutgoingRtpPackets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      marker_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      payload_type_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      sequence_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      rtp_timestamp_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      ssrc_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      payload_size_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      header_size_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      padding_size_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      transport_sequence_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      transmission_time_offset_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      absolute_send_time_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00001000u) {
      video_rotation_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00002000u) {
      audio_level_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00004000u) {
      voice_activity_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(dependency_descriptor_ != nullptr);
      dependency_descriptor_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&padding_size_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(padding_size_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&number_of_deltas_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&audio_level_) -
        reinterpret_cast<char*>(&number_of_deltas_)) + sizeof(audio_level_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OutgoingRtpPackets::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool marker = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_marker(&has_bits);
          marker_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 payload_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_payload_type(&has_bits);
          payload_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sequence_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sequence_number(&has_bits);
          sequence_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 rtp_timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_rtp_timestamp(&has_bits);
          rtp_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 ssrc = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_ssrc(&has_bits);
          ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 payload_size = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_payload_size(&has_bits);
          payload_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 header_size = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_header_size(&has_bits);
          header_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 padding_size = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_padding_size(&has_bits);
          padding_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 transport_sequence_number = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_transport_sequence_number(&has_bits);
          transport_sequence_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 transmission_time_offset = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_transmission_time_offset(&has_bits);
          transmission_time_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 absolute_send_time = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_absolute_send_time(&has_bits);
          absolute_send_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 video_rotation = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_video_rotation(&has_bits);
          video_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 audio_level = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_audio_level(&has_bits);
          audio_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool voice_activity = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_voice_activity(&has_bits);
          voice_activity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_dependency_descriptor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes marker_deltas = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_marker_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payload_type_deltas = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_payload_type_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes sequence_number_deltas = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_sequence_number_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes rtp_timestamp_deltas = 105;
      case 105:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_rtp_timestamp_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ssrc_deltas = 106;
      case 106:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_ssrc_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payload_size_deltas = 108;
      case 108:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_payload_size_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes header_size_deltas = 109;
      case 109:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_header_size_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes padding_size_deltas = 110;
      case 110:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_padding_size_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes transport_sequence_number_deltas = 115;
      case 115:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_transport_sequence_number_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes transmission_time_offset_deltas = 116;
      case 116:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_transmission_time_offset_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes absolute_send_time_deltas = 117;
      case 117:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_absolute_send_time_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes video_rotation_deltas = 118;
      case 118:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_video_rotation_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes audio_level_deltas = 119;
      case 119:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_audio_level_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes voice_activity_deltas = 120;
      case 120:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          auto str = _internal_mutable_voice_activity_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OutgoingRtpPackets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.OutgoingRtpPackets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional bool marker = 2;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_marker(), target);
  }

  // optional uint32 payload_type = 3;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_payload_type(), target);
  }

  // optional uint32 sequence_number = 4;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_sequence_number(), target);
  }

  // optional fixed32 rtp_timestamp = 5;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_rtp_timestamp(), target);
  }

  // optional fixed32 ssrc = 6;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_ssrc(), target);
  }

  // optional uint32 payload_size = 8;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_payload_size(), target);
  }

  // optional uint32 header_size = 9;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_header_size(), target);
  }

  // optional uint32 padding_size = 10;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_padding_size(), target);
  }

  // optional uint32 number_of_deltas = 11;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_number_of_deltas(), target);
  }

  // optional uint32 transport_sequence_number = 15;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_transport_sequence_number(), target);
  }

  // optional int32 transmission_time_offset = 16;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_transmission_time_offset(), target);
  }

  // optional uint32 absolute_send_time = 17;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_absolute_send_time(), target);
  }

  // optional uint32 video_rotation = 18;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_video_rotation(), target);
  }

  // optional uint32 audio_level = 19;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_audio_level(), target);
  }

  // optional bool voice_activity = 20;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_voice_activity(), target);
  }

  // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::dependency_descriptor(this),
        _Internal::dependency_descriptor(this).GetCachedSize(), target, stream);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        101, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes marker_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        102, this->_internal_marker_deltas(), target);
  }

  // optional bytes payload_type_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        103, this->_internal_payload_type_deltas(), target);
  }

  // optional bytes sequence_number_deltas = 104;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        104, this->_internal_sequence_number_deltas(), target);
  }

  // optional bytes rtp_timestamp_deltas = 105;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        105, this->_internal_rtp_timestamp_deltas(), target);
  }

  // optional bytes ssrc_deltas = 106;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        106, this->_internal_ssrc_deltas(), target);
  }

  // optional bytes payload_size_deltas = 108;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        108, this->_internal_payload_size_deltas(), target);
  }

  // optional bytes header_size_deltas = 109;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteBytesMaybeAliased(
        109, this->_internal_header_size_deltas(), target);
  }

  // optional bytes padding_size_deltas = 110;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteBytesMaybeAliased(
        110, this->_internal_padding_size_deltas(), target);
  }

  // optional bytes transport_sequence_number_deltas = 115;
  if (cached_has_bits & 0x00000200u) {
    target = stream->WriteBytesMaybeAliased(
        115, this->_internal_transport_sequence_number_deltas(), target);
  }

  // optional bytes transmission_time_offset_deltas = 116;
  if (cached_has_bits & 0x00000400u) {
    target = stream->WriteBytesMaybeAliased(
        116, this->_internal_transmission_time_offset_deltas(), target);
  }

  // optional bytes absolute_send_time_deltas = 117;
  if (cached_has_bits & 0x00000800u) {
    target = stream->WriteBytesMaybeAliased(
        117, this->_internal_absolute_send_time_deltas(), target);
  }

  // optional bytes video_rotation_deltas = 118;
  if (cached_has_bits & 0x00001000u) {
    target = stream->WriteBytesMaybeAliased(
        118, this->_internal_video_rotation_deltas(), target);
  }

  // optional bytes audio_level_deltas = 119;
  if (cached_has_bits & 0x00002000u) {
    target = stream->WriteBytesMaybeAliased(
        119, this->_internal_audio_level_deltas(), target);
  }

  // optional bytes voice_activity_deltas = 120;
  if (cached_has_bits & 0x00004000u) {
    target = stream->WriteBytesMaybeAliased(
        120, this->_internal_voice_activity_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.OutgoingRtpPackets)
  return target;
}

size_t OutgoingRtpPackets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.OutgoingRtpPackets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes marker_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_marker_deltas());
    }

    // optional bytes payload_type_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload_type_deltas());
    }

    // optional bytes sequence_number_deltas = 104;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_sequence_number_deltas());
    }

    // optional bytes rtp_timestamp_deltas = 105;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_rtp_timestamp_deltas());
    }

    // optional bytes ssrc_deltas = 106;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ssrc_deltas());
    }

    // optional bytes payload_size_deltas = 108;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload_size_deltas());
    }

    // optional bytes header_size_deltas = 109;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_header_size_deltas());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bytes padding_size_deltas = 110;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_padding_size_deltas());
    }

    // optional bytes transport_sequence_number_deltas = 115;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_transport_sequence_number_deltas());
    }

    // optional bytes transmission_time_offset_deltas = 116;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_transmission_time_offset_deltas());
    }

    // optional bytes absolute_send_time_deltas = 117;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_absolute_send_time_deltas());
    }

    // optional bytes video_rotation_deltas = 118;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_video_rotation_deltas());
    }

    // optional bytes audio_level_deltas = 119;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_audio_level_deltas());
    }

    // optional bytes voice_activity_deltas = 120;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_voice_activity_deltas());
    }

    // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dependency_descriptor_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 payload_type = 3;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_payload_type());
    }

    // optional uint32 sequence_number = 4;
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sequence_number());
    }

    // optional fixed32 rtp_timestamp = 5;
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 4;
    }

    // optional fixed32 ssrc = 6;
    if (cached_has_bits & 0x00100000u) {
      total_size += 1 + 4;
    }

    // optional uint32 payload_size = 8;
    if (cached_has_bits & 0x00200000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_payload_size());
    }

    // optional uint32 header_size = 9;
    if (cached_has_bits & 0x00400000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_header_size());
    }

    // optional uint32 padding_size = 10;
    if (cached_has_bits & 0x00800000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_padding_size());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 number_of_deltas = 11;
    if (cached_has_bits & 0x01000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_deltas());
    }

    // optional bool marker = 2;
    if (cached_has_bits & 0x02000000u) {
      total_size += 1 + 1;
    }

    // optional bool voice_activity = 20;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional uint32 transport_sequence_number = 15;
    if (cached_has_bits & 0x08000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_transport_sequence_number());
    }

    // optional int32 transmission_time_offset = 16;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_transmission_time_offset());
    }

    // optional uint32 absolute_send_time = 17;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_absolute_send_time());
    }

    // optional uint32 video_rotation = 18;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_video_rotation());
    }

    // optional uint32 audio_level = 19;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_audio_level());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OutgoingRtpPackets::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OutgoingRtpPackets*>(
      &from));
}

void OutgoingRtpPackets::MergeFrom(const OutgoingRtpPackets& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.OutgoingRtpPackets)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_marker_deltas(from._internal_marker_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_payload_type_deltas(from._internal_payload_type_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_sequence_number_deltas(from._internal_sequence_number_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_rtp_timestamp_deltas(from._internal_rtp_timestamp_deltas());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_ssrc_deltas(from._internal_ssrc_deltas());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_payload_size_deltas(from._internal_payload_size_deltas());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_header_size_deltas(from._internal_header_size_deltas());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_set_padding_size_deltas(from._internal_padding_size_deltas());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_set_transport_sequence_number_deltas(from._internal_transport_sequence_number_deltas());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_set_transmission_time_offset_deltas(from._internal_transmission_time_offset_deltas());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_set_absolute_send_time_deltas(from._internal_absolute_send_time_deltas());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_set_video_rotation_deltas(from._internal_video_rotation_deltas());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_set_audio_level_deltas(from._internal_audio_level_deltas());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_set_voice_activity_deltas(from._internal_voice_activity_deltas());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_dependency_descriptor()->::webrtc::rtclog2::DependencyDescriptorsWireInfo::MergeFrom(from._internal_dependency_descriptor());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00020000u) {
      payload_type_ = from.payload_type_;
    }
    if (cached_has_bits & 0x00040000u) {
      sequence_number_ = from.sequence_number_;
    }
    if (cached_has_bits & 0x00080000u) {
      rtp_timestamp_ = from.rtp_timestamp_;
    }
    if (cached_has_bits & 0x00100000u) {
      ssrc_ = from.ssrc_;
    }
    if (cached_has_bits & 0x00200000u) {
      payload_size_ = from.payload_size_;
    }
    if (cached_has_bits & 0x00400000u) {
      header_size_ = from.header_size_;
    }
    if (cached_has_bits & 0x00800000u) {
      padding_size_ = from.padding_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    if (cached_has_bits & 0x02000000u) {
      marker_ = from.marker_;
    }
    if (cached_has_bits & 0x04000000u) {
      voice_activity_ = from.voice_activity_;
    }
    if (cached_has_bits & 0x08000000u) {
      transport_sequence_number_ = from.transport_sequence_number_;
    }
    if (cached_has_bits & 0x10000000u) {
      transmission_time_offset_ = from.transmission_time_offset_;
    }
    if (cached_has_bits & 0x20000000u) {
      absolute_send_time_ = from.absolute_send_time_;
    }
    if (cached_has_bits & 0x40000000u) {
      video_rotation_ = from.video_rotation_;
    }
    if (cached_has_bits & 0x80000000u) {
      audio_level_ = from.audio_level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OutgoingRtpPackets::CopyFrom(const OutgoingRtpPackets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.OutgoingRtpPackets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OutgoingRtpPackets::IsInitialized() const {
  return true;
}

void OutgoingRtpPackets::InternalSwap(OutgoingRtpPackets* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &marker_deltas_, lhs_arena,
      &other->marker_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &payload_type_deltas_, lhs_arena,
      &other->payload_type_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sequence_number_deltas_, lhs_arena,
      &other->sequence_number_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &rtp_timestamp_deltas_, lhs_arena,
      &other->rtp_timestamp_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ssrc_deltas_, lhs_arena,
      &other->ssrc_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &payload_size_deltas_, lhs_arena,
      &other->payload_size_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &header_size_deltas_, lhs_arena,
      &other->header_size_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &padding_size_deltas_, lhs_arena,
      &other->padding_size_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &transport_sequence_number_deltas_, lhs_arena,
      &other->transport_sequence_number_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &transmission_time_offset_deltas_, lhs_arena,
      &other->transmission_time_offset_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &absolute_send_time_deltas_, lhs_arena,
      &other->absolute_send_time_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &video_rotation_deltas_, lhs_arena,
      &other->video_rotation_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &audio_level_deltas_, lhs_arena,
      &other->audio_level_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &voice_activity_deltas_, lhs_arena,
      &other->voice_activity_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, audio_level_)
      + sizeof(OutgoingRtpPackets::audio_level_)
      - PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, dependency_descriptor_)>(
          reinterpret_cast<char*>(&dependency_descriptor_),
          reinterpret_cast<char*>(&other->dependency_descriptor_));
}

std::string OutgoingRtpPackets::GetTypeName() const {
  return "webrtc.rtclog2.OutgoingRtpPackets";
}


// ===================================================================

class IncomingRtcpPackets::_Internal {
 public:
  using HasBits = decltype(std::declval<IncomingRtcpPackets>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_raw_packet(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_raw_packet_blobs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IncomingRtcpPackets::IncomingRtcpPackets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.IncomingRtcpPackets)
}
IncomingRtcpPackets::IncomingRtcpPackets(const IncomingRtcpPackets& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  raw_packet_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    raw_packet_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_raw_packet()) {
    raw_packet_.Set(from._internal_raw_packet(), 
      GetArenaForAllocation());
  }
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  raw_packet_blobs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    raw_packet_blobs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_raw_packet_blobs()) {
    raw_packet_blobs_.Set(from._internal_raw_packet_blobs(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.IncomingRtcpPackets)
}

inline void IncomingRtcpPackets::SharedCtor() {
raw_packet_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  raw_packet_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
raw_packet_blobs_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  raw_packet_blobs_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

IncomingRtcpPackets::~IncomingRtcpPackets() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.IncomingRtcpPackets)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IncomingRtcpPackets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  raw_packet_.Destroy();
  timestamp_ms_deltas_.Destroy();
  raw_packet_blobs_.Destroy();
}

void IncomingRtcpPackets::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IncomingRtcpPackets::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.IncomingRtcpPackets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      raw_packet_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      raw_packet_blobs_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_deltas_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IncomingRtcpPackets::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes raw_packet = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_raw_packet();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes raw_packet_blobs = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_raw_packet_blobs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IncomingRtcpPackets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.IncomingRtcpPackets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional bytes raw_packet = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_raw_packet(), target);
  }

  // optional uint32 number_of_deltas = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        101, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes raw_packet_blobs = 102;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        102, this->_internal_raw_packet_blobs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.IncomingRtcpPackets)
  return target;
}

size_t IncomingRtcpPackets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.IncomingRtcpPackets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes raw_packet = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_raw_packet());
    }

    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes raw_packet_blobs = 102;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_raw_packet_blobs());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 number_of_deltas = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IncomingRtcpPackets::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IncomingRtcpPackets*>(
      &from));
}

void IncomingRtcpPackets::MergeFrom(const IncomingRtcpPackets& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.IncomingRtcpPackets)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_raw_packet(from._internal_raw_packet());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_raw_packet_blobs(from._internal_raw_packet_blobs());
    }
    if (cached_has_bits & 0x00000008u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IncomingRtcpPackets::CopyFrom(const IncomingRtcpPackets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.IncomingRtcpPackets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IncomingRtcpPackets::IsInitialized() const {
  return true;
}

void IncomingRtcpPackets::InternalSwap(IncomingRtcpPackets* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &raw_packet_, lhs_arena,
      &other->raw_packet_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &raw_packet_blobs_, lhs_arena,
      &other->raw_packet_blobs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, number_of_deltas_)
      + sizeof(IncomingRtcpPackets::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string IncomingRtcpPackets::GetTypeName() const {
  return "webrtc.rtclog2.IncomingRtcpPackets";
}


// ===================================================================

class OutgoingRtcpPackets::_Internal {
 public:
  using HasBits = decltype(std::declval<OutgoingRtcpPackets>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_raw_packet(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_raw_packet_blobs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

OutgoingRtcpPackets::OutgoingRtcpPackets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.OutgoingRtcpPackets)
}
OutgoingRtcpPackets::OutgoingRtcpPackets(const OutgoingRtcpPackets& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  raw_packet_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    raw_packet_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_raw_packet()) {
    raw_packet_.Set(from._internal_raw_packet(), 
      GetArenaForAllocation());
  }
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  raw_packet_blobs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    raw_packet_blobs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_raw_packet_blobs()) {
    raw_packet_blobs_.Set(from._internal_raw_packet_blobs(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.OutgoingRtcpPackets)
}

inline void OutgoingRtcpPackets::SharedCtor() {
raw_packet_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  raw_packet_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
raw_packet_blobs_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  raw_packet_blobs_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

OutgoingRtcpPackets::~OutgoingRtcpPackets() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.OutgoingRtcpPackets)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OutgoingRtcpPackets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  raw_packet_.Destroy();
  timestamp_ms_deltas_.Destroy();
  raw_packet_blobs_.Destroy();
}

void OutgoingRtcpPackets::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OutgoingRtcpPackets::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.OutgoingRtcpPackets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      raw_packet_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      raw_packet_blobs_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_deltas_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OutgoingRtcpPackets::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes raw_packet = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_raw_packet();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes raw_packet_blobs = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_raw_packet_blobs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OutgoingRtcpPackets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.OutgoingRtcpPackets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional bytes raw_packet = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_raw_packet(), target);
  }

  // optional uint32 number_of_deltas = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        101, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes raw_packet_blobs = 102;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        102, this->_internal_raw_packet_blobs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.OutgoingRtcpPackets)
  return target;
}

size_t OutgoingRtcpPackets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.OutgoingRtcpPackets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes raw_packet = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_raw_packet());
    }

    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes raw_packet_blobs = 102;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_raw_packet_blobs());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 number_of_deltas = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OutgoingRtcpPackets::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OutgoingRtcpPackets*>(
      &from));
}

void OutgoingRtcpPackets::MergeFrom(const OutgoingRtcpPackets& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.OutgoingRtcpPackets)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_raw_packet(from._internal_raw_packet());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_raw_packet_blobs(from._internal_raw_packet_blobs());
    }
    if (cached_has_bits & 0x00000008u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OutgoingRtcpPackets::CopyFrom(const OutgoingRtcpPackets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.OutgoingRtcpPackets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OutgoingRtcpPackets::IsInitialized() const {
  return true;
}

void OutgoingRtcpPackets::InternalSwap(OutgoingRtcpPackets* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &raw_packet_, lhs_arena,
      &other->raw_packet_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &raw_packet_blobs_, lhs_arena,
      &other->raw_packet_blobs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, number_of_deltas_)
      + sizeof(OutgoingRtcpPackets::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string OutgoingRtcpPackets::GetTypeName() const {
  return "webrtc.rtclog2.OutgoingRtcpPackets";
}


// ===================================================================

class AudioPlayoutEvents::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioPlayoutEvents>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_local_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_local_ssrc_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AudioPlayoutEvents::AudioPlayoutEvents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.AudioPlayoutEvents)
}
AudioPlayoutEvents::AudioPlayoutEvents(const AudioPlayoutEvents& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  local_ssrc_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    local_ssrc_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_local_ssrc_deltas()) {
    local_ssrc_deltas_.Set(from._internal_local_ssrc_deltas(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.AudioPlayoutEvents)
}

inline void AudioPlayoutEvents::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
local_ssrc_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  local_ssrc_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

AudioPlayoutEvents::~AudioPlayoutEvents() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.AudioPlayoutEvents)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioPlayoutEvents::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  local_ssrc_deltas_.Destroy();
}

void AudioPlayoutEvents::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AudioPlayoutEvents::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.AudioPlayoutEvents)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      local_ssrc_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_deltas_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioPlayoutEvents::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 local_ssrc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_local_ssrc(&has_bits);
          local_ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes local_ssrc_deltas = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_local_ssrc_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioPlayoutEvents::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.AudioPlayoutEvents)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 local_ssrc = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_local_ssrc(), target);
  }

  // optional uint32 number_of_deltas = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        101, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes local_ssrc_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        102, this->_internal_local_ssrc_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.AudioPlayoutEvents)
  return target;
}

size_t AudioPlayoutEvents::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.AudioPlayoutEvents)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes local_ssrc_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_local_ssrc_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 local_ssrc = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_local_ssrc());
    }

    // optional uint32 number_of_deltas = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioPlayoutEvents::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AudioPlayoutEvents*>(
      &from));
}

void AudioPlayoutEvents::MergeFrom(const AudioPlayoutEvents& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.AudioPlayoutEvents)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_local_ssrc_deltas(from._internal_local_ssrc_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000008u) {
      local_ssrc_ = from.local_ssrc_;
    }
    if (cached_has_bits & 0x00000010u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioPlayoutEvents::CopyFrom(const AudioPlayoutEvents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.AudioPlayoutEvents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioPlayoutEvents::IsInitialized() const {
  return true;
}

void AudioPlayoutEvents::InternalSwap(AudioPlayoutEvents* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &local_ssrc_deltas_, lhs_arena,
      &other->local_ssrc_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, number_of_deltas_)
      + sizeof(AudioPlayoutEvents::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string AudioPlayoutEvents::GetTypeName() const {
  return "webrtc.rtclog2.AudioPlayoutEvents";
}


// ===================================================================

class NetEqSetMinimumDelay::_Internal {
 public:
  using HasBits = decltype(std::declval<NetEqSetMinimumDelay>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_remote_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_minimum_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_remote_ssrc_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_minimum_delay_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

NetEqSetMinimumDelay::NetEqSetMinimumDelay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.NetEqSetMinimumDelay)
}
NetEqSetMinimumDelay::NetEqSetMinimumDelay(const NetEqSetMinimumDelay& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  remote_ssrc_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    remote_ssrc_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_remote_ssrc_deltas()) {
    remote_ssrc_deltas_.Set(from._internal_remote_ssrc_deltas(), 
      GetArenaForAllocation());
  }
  minimum_delay_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    minimum_delay_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_minimum_delay_ms_deltas()) {
    minimum_delay_ms_deltas_.Set(from._internal_minimum_delay_ms_deltas(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.NetEqSetMinimumDelay)
}

inline void NetEqSetMinimumDelay::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
remote_ssrc_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  remote_ssrc_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
minimum_delay_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  minimum_delay_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

NetEqSetMinimumDelay::~NetEqSetMinimumDelay() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.NetEqSetMinimumDelay)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetEqSetMinimumDelay::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  remote_ssrc_deltas_.Destroy();
  minimum_delay_ms_deltas_.Destroy();
}

void NetEqSetMinimumDelay::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NetEqSetMinimumDelay::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.NetEqSetMinimumDelay)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      remote_ssrc_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      minimum_delay_ms_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_deltas_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NetEqSetMinimumDelay::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 remote_ssrc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_remote_ssrc(&has_bits);
          remote_ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 minimum_delay_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_minimum_delay_ms(&has_bits);
          minimum_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes remote_ssrc_deltas = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_remote_ssrc_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes minimum_delay_ms_deltas = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_minimum_delay_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetEqSetMinimumDelay::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.NetEqSetMinimumDelay)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional fixed32 remote_ssrc = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_remote_ssrc(), target);
  }

  // optional int32 minimum_delay_ms = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_minimum_delay_ms(), target);
  }

  // optional uint32 number_of_deltas = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        101, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes remote_ssrc_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        102, this->_internal_remote_ssrc_deltas(), target);
  }

  // optional bytes minimum_delay_ms_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        103, this->_internal_minimum_delay_ms_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.NetEqSetMinimumDelay)
  return target;
}

size_t NetEqSetMinimumDelay::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.NetEqSetMinimumDelay)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes remote_ssrc_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_remote_ssrc_deltas());
    }

    // optional bytes minimum_delay_ms_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_minimum_delay_ms_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional fixed32 remote_ssrc = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional int32 minimum_delay_ms = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minimum_delay_ms());
    }

    // optional uint32 number_of_deltas = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetEqSetMinimumDelay::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetEqSetMinimumDelay*>(
      &from));
}

void NetEqSetMinimumDelay::MergeFrom(const NetEqSetMinimumDelay& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.NetEqSetMinimumDelay)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_remote_ssrc_deltas(from._internal_remote_ssrc_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_minimum_delay_ms_deltas(from._internal_minimum_delay_ms_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      remote_ssrc_ = from.remote_ssrc_;
    }
    if (cached_has_bits & 0x00000020u) {
      minimum_delay_ms_ = from.minimum_delay_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetEqSetMinimumDelay::CopyFrom(const NetEqSetMinimumDelay& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.NetEqSetMinimumDelay)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetEqSetMinimumDelay::IsInitialized() const {
  return true;
}

void NetEqSetMinimumDelay::InternalSwap(NetEqSetMinimumDelay* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &remote_ssrc_deltas_, lhs_arena,
      &other->remote_ssrc_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &minimum_delay_ms_deltas_, lhs_arena,
      &other->minimum_delay_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, number_of_deltas_)
      + sizeof(NetEqSetMinimumDelay::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string NetEqSetMinimumDelay::GetTypeName() const {
  return "webrtc.rtclog2.NetEqSetMinimumDelay";
}


// ===================================================================

class FrameDecodedEvents::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameDecodedEvents>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_render_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_qp(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ssrc_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_render_time_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_width_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_height_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_codec_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_qp_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

FrameDecodedEvents::FrameDecodedEvents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.FrameDecodedEvents)
}
FrameDecodedEvents::FrameDecodedEvents(const FrameDecodedEvents& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  ssrc_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ssrc_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ssrc_deltas()) {
    ssrc_deltas_.Set(from._internal_ssrc_deltas(), 
      GetArenaForAllocation());
  }
  render_time_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    render_time_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_render_time_ms_deltas()) {
    render_time_ms_deltas_.Set(from._internal_render_time_ms_deltas(), 
      GetArenaForAllocation());
  }
  width_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    width_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_width_deltas()) {
    width_deltas_.Set(from._internal_width_deltas(), 
      GetArenaForAllocation());
  }
  height_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    height_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_height_deltas()) {
    height_deltas_.Set(from._internal_height_deltas(), 
      GetArenaForAllocation());
  }
  codec_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    codec_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_codec_deltas()) {
    codec_deltas_.Set(from._internal_codec_deltas(), 
      GetArenaForAllocation());
  }
  qp_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    qp_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_qp_deltas()) {
    qp_deltas_.Set(from._internal_qp_deltas(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.FrameDecodedEvents)
}

inline void FrameDecodedEvents::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ssrc_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ssrc_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
render_time_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  render_time_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
width_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  width_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
height_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  height_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
codec_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  codec_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
qp_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  qp_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

FrameDecodedEvents::~FrameDecodedEvents() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.FrameDecodedEvents)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FrameDecodedEvents::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  ssrc_deltas_.Destroy();
  render_time_ms_deltas_.Destroy();
  width_deltas_.Destroy();
  height_deltas_.Destroy();
  codec_deltas_.Destroy();
  qp_deltas_.Destroy();
}

void FrameDecodedEvents::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FrameDecodedEvents::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.FrameDecodedEvents)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ssrc_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      render_time_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      width_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      height_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      codec_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      qp_deltas_.ClearNonDefaultToEmpty();
    }
  }
  timestamp_ms_ = int64_t{0};
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&render_time_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_deltas_) -
        reinterpret_cast<char*>(&render_time_ms_)) + sizeof(number_of_deltas_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FrameDecodedEvents::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 ssrc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_ssrc(&has_bits);
          ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional int64 render_time_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_render_time_ms(&has_bits);
          render_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.FrameDecodedEvents.Codec codec = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::FrameDecodedEvents_Codec_IsValid(val))) {
            _internal_set_codec(static_cast<::webrtc::rtclog2::FrameDecodedEvents_Codec>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 qp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_qp(&has_bits);
          qp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ssrc_deltas = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_ssrc_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes render_time_ms_deltas = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_render_time_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes width_deltas = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_width_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes height_deltas = 105;
      case 105:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_height_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes codec_deltas = 106;
      case 106:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_codec_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes qp_deltas = 107;
      case 107:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_qp_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FrameDecodedEvents::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.FrameDecodedEvents)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional fixed32 ssrc = 2;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_ssrc(), target);
  }

  // optional int64 render_time_ms = 3;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_render_time_ms(), target);
  }

  // optional int32 width = 4;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_width(), target);
  }

  // optional int32 height = 5;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_height(), target);
  }

  // optional .webrtc.rtclog2.FrameDecodedEvents.Codec codec = 6;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_codec(), target);
  }

  // optional uint32 qp = 7;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_qp(), target);
  }

  // optional uint32 number_of_deltas = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        101, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes ssrc_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        102, this->_internal_ssrc_deltas(), target);
  }

  // optional bytes render_time_ms_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        103, this->_internal_render_time_ms_deltas(), target);
  }

  // optional bytes width_deltas = 104;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        104, this->_internal_width_deltas(), target);
  }

  // optional bytes height_deltas = 105;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        105, this->_internal_height_deltas(), target);
  }

  // optional bytes codec_deltas = 106;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        106, this->_internal_codec_deltas(), target);
  }

  // optional bytes qp_deltas = 107;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        107, this->_internal_qp_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.FrameDecodedEvents)
  return target;
}

size_t FrameDecodedEvents::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.FrameDecodedEvents)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes ssrc_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ssrc_deltas());
    }

    // optional bytes render_time_ms_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_render_time_ms_deltas());
    }

    // optional bytes width_deltas = 104;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_width_deltas());
    }

    // optional bytes height_deltas = 105;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_height_deltas());
    }

    // optional bytes codec_deltas = 106;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_codec_deltas());
    }

    // optional bytes qp_deltas = 107;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_qp_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional int64 render_time_ms = 3;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_render_time_ms());
    }

    // optional fixed32 ssrc = 2;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional int32 width = 4;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 5;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

    // optional .webrtc.rtclog2.FrameDecodedEvents.Codec codec = 6;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_codec());
    }

    // optional uint32 qp = 7;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_qp());
    }

    // optional uint32 number_of_deltas = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FrameDecodedEvents::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FrameDecodedEvents*>(
      &from));
}

void FrameDecodedEvents::MergeFrom(const FrameDecodedEvents& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.FrameDecodedEvents)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ssrc_deltas(from._internal_ssrc_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_render_time_ms_deltas(from._internal_render_time_ms_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_width_deltas(from._internal_width_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_height_deltas(from._internal_height_deltas());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_codec_deltas(from._internal_codec_deltas());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_qp_deltas(from._internal_qp_deltas());
    }
    if (cached_has_bits & 0x00000080u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      render_time_ms_ = from.render_time_ms_;
    }
    if (cached_has_bits & 0x00000200u) {
      ssrc_ = from.ssrc_;
    }
    if (cached_has_bits & 0x00000400u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000800u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00001000u) {
      codec_ = from.codec_;
    }
    if (cached_has_bits & 0x00002000u) {
      qp_ = from.qp_;
    }
    if (cached_has_bits & 0x00004000u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FrameDecodedEvents::CopyFrom(const FrameDecodedEvents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.FrameDecodedEvents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameDecodedEvents::IsInitialized() const {
  return true;
}

void FrameDecodedEvents::InternalSwap(FrameDecodedEvents* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ssrc_deltas_, lhs_arena,
      &other->ssrc_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &render_time_ms_deltas_, lhs_arena,
      &other->render_time_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &width_deltas_, lhs_arena,
      &other->width_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &height_deltas_, lhs_arena,
      &other->height_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &codec_deltas_, lhs_arena,
      &other->codec_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &qp_deltas_, lhs_arena,
      &other->qp_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, number_of_deltas_)
      + sizeof(FrameDecodedEvents::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string FrameDecodedEvents::GetTypeName() const {
  return "webrtc.rtclog2.FrameDecodedEvents";
}


// ===================================================================

class BeginLogEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<BeginLogEvent>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_utc_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BeginLogEvent::BeginLogEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.BeginLogEvent)
}
BeginLogEvent::BeginLogEvent(const BeginLogEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(version_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.BeginLogEvent)
}

inline void BeginLogEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(version_));
}

BeginLogEvent::~BeginLogEvent() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.BeginLogEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BeginLogEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BeginLogEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BeginLogEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.BeginLogEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&version_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BeginLogEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 utc_time_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_utc_time_ms(&has_bits);
          utc_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BeginLogEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.BeginLogEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 version = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_version(), target);
  }

  // optional int64 utc_time_ms = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_utc_time_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.BeginLogEvent)
  return target;
}

size_t BeginLogEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.BeginLogEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional int64 utc_time_ms = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_utc_time_ms());
    }

    // optional uint32 version = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BeginLogEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BeginLogEvent*>(
      &from));
}

void BeginLogEvent::MergeFrom(const BeginLogEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.BeginLogEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      utc_time_ms_ = from.utc_time_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BeginLogEvent::CopyFrom(const BeginLogEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.BeginLogEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeginLogEvent::IsInitialized() const {
  return true;
}

void BeginLogEvent::InternalSwap(BeginLogEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BeginLogEvent, version_)
      + sizeof(BeginLogEvent::version_)
      - PROTOBUF_FIELD_OFFSET(BeginLogEvent, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string BeginLogEvent::GetTypeName() const {
  return "webrtc.rtclog2.BeginLogEvent";
}


// ===================================================================

class EndLogEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<EndLogEvent>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EndLogEvent::EndLogEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.EndLogEvent)
}
EndLogEvent::EndLogEvent(const EndLogEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_ = from.timestamp_ms_;
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.EndLogEvent)
}

inline void EndLogEvent::SharedCtor() {
timestamp_ms_ = int64_t{0};
}

EndLogEvent::~EndLogEvent() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.EndLogEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EndLogEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EndLogEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EndLogEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.EndLogEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  timestamp_ms_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EndLogEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EndLogEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.EndLogEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.EndLogEvent)
  return target;
}

size_t EndLogEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.EndLogEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 timestamp_ms = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EndLogEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EndLogEvent*>(
      &from));
}

void EndLogEvent::MergeFrom(const EndLogEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.EndLogEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_timestamp_ms()) {
    _internal_set_timestamp_ms(from._internal_timestamp_ms());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EndLogEvent::CopyFrom(const EndLogEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.EndLogEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndLogEvent::IsInitialized() const {
  return true;
}

void EndLogEvent::InternalSwap(EndLogEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(timestamp_ms_, other->timestamp_ms_);
}

std::string EndLogEvent::GetTypeName() const {
  return "webrtc.rtclog2.EndLogEvent";
}


// ===================================================================

class LossBasedBweUpdates::_Internal {
 public:
  using HasBits = decltype(std::declval<LossBasedBweUpdates>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_fraction_loss(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_total_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bitrate_bps_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fraction_loss_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_total_packets_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

LossBasedBweUpdates::LossBasedBweUpdates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.LossBasedBweUpdates)
}
LossBasedBweUpdates::LossBasedBweUpdates(const LossBasedBweUpdates& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  bitrate_bps_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    bitrate_bps_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bitrate_bps_deltas()) {
    bitrate_bps_deltas_.Set(from._internal_bitrate_bps_deltas(), 
      GetArenaForAllocation());
  }
  fraction_loss_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    fraction_loss_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fraction_loss_deltas()) {
    fraction_loss_deltas_.Set(from._internal_fraction_loss_deltas(), 
      GetArenaForAllocation());
  }
  total_packets_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    total_packets_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_total_packets_deltas()) {
    total_packets_deltas_.Set(from._internal_total_packets_deltas(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.LossBasedBweUpdates)
}

inline void LossBasedBweUpdates::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
bitrate_bps_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  bitrate_bps_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
fraction_loss_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  fraction_loss_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
total_packets_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  total_packets_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

LossBasedBweUpdates::~LossBasedBweUpdates() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.LossBasedBweUpdates)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LossBasedBweUpdates::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  bitrate_bps_deltas_.Destroy();
  fraction_loss_deltas_.Destroy();
  total_packets_deltas_.Destroy();
}

void LossBasedBweUpdates::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LossBasedBweUpdates::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.LossBasedBweUpdates)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      bitrate_bps_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      fraction_loss_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      total_packets_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&total_packets_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(total_packets_));
  }
  number_of_deltas_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LossBasedBweUpdates::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bitrate_bps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bitrate_bps(&has_bits);
          bitrate_bps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fraction_loss = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_fraction_loss(&has_bits);
          fraction_loss_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 total_packets = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_total_packets(&has_bits);
          total_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes bitrate_bps_deltas = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_bitrate_bps_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fraction_loss_deltas = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_fraction_loss_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes total_packets_deltas = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_total_packets_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LossBasedBweUpdates::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.LossBasedBweUpdates)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 bitrate_bps = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_bitrate_bps(), target);
  }

  // optional uint32 fraction_loss = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_fraction_loss(), target);
  }

  // optional uint32 total_packets = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_total_packets(), target);
  }

  // optional uint32 number_of_deltas = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        101, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes bitrate_bps_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        102, this->_internal_bitrate_bps_deltas(), target);
  }

  // optional bytes fraction_loss_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        103, this->_internal_fraction_loss_deltas(), target);
  }

  // optional bytes total_packets_deltas = 104;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        104, this->_internal_total_packets_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.LossBasedBweUpdates)
  return target;
}

size_t LossBasedBweUpdates::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.LossBasedBweUpdates)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes bitrate_bps_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_bitrate_bps_deltas());
    }

    // optional bytes fraction_loss_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fraction_loss_deltas());
    }

    // optional bytes total_packets_deltas = 104;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_total_packets_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 bitrate_bps = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bitrate_bps());
    }

    // optional uint32 fraction_loss = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fraction_loss());
    }

    // optional uint32 total_packets = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_packets());
    }

  }
  // optional uint32 number_of_deltas = 5;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_deltas());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LossBasedBweUpdates::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LossBasedBweUpdates*>(
      &from));
}

void LossBasedBweUpdates::MergeFrom(const LossBasedBweUpdates& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.LossBasedBweUpdates)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_bitrate_bps_deltas(from._internal_bitrate_bps_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_fraction_loss_deltas(from._internal_fraction_loss_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_total_packets_deltas(from._internal_total_packets_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000020u) {
      bitrate_bps_ = from.bitrate_bps_;
    }
    if (cached_has_bits & 0x00000040u) {
      fraction_loss_ = from.fraction_loss_;
    }
    if (cached_has_bits & 0x00000080u) {
      total_packets_ = from.total_packets_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_number_of_deltas(from._internal_number_of_deltas());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LossBasedBweUpdates::CopyFrom(const LossBasedBweUpdates& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.LossBasedBweUpdates)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LossBasedBweUpdates::IsInitialized() const {
  return true;
}

void LossBasedBweUpdates::InternalSwap(LossBasedBweUpdates* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &bitrate_bps_deltas_, lhs_arena,
      &other->bitrate_bps_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &fraction_loss_deltas_, lhs_arena,
      &other->fraction_loss_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &total_packets_deltas_, lhs_arena,
      &other->total_packets_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, number_of_deltas_)
      + sizeof(LossBasedBweUpdates::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string LossBasedBweUpdates::GetTypeName() const {
  return "webrtc.rtclog2.LossBasedBweUpdates";
}


// ===================================================================

class DelayBasedBweUpdates::_Internal {
 public:
  using HasBits = decltype(std::declval<DelayBasedBweUpdates>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_detector_state(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bitrate_bps_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_detector_state_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

DelayBasedBweUpdates::DelayBasedBweUpdates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.DelayBasedBweUpdates)
}
DelayBasedBweUpdates::DelayBasedBweUpdates(const DelayBasedBweUpdates& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  bitrate_bps_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    bitrate_bps_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bitrate_bps_deltas()) {
    bitrate_bps_deltas_.Set(from._internal_bitrate_bps_deltas(), 
      GetArenaForAllocation());
  }
  detector_state_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    detector_state_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_detector_state_deltas()) {
    detector_state_deltas_.Set(from._internal_detector_state_deltas(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.DelayBasedBweUpdates)
}

inline void DelayBasedBweUpdates::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
bitrate_bps_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  bitrate_bps_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
detector_state_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  detector_state_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

DelayBasedBweUpdates::~DelayBasedBweUpdates() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.DelayBasedBweUpdates)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DelayBasedBweUpdates::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  bitrate_bps_deltas_.Destroy();
  detector_state_deltas_.Destroy();
}

void DelayBasedBweUpdates::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DelayBasedBweUpdates::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.DelayBasedBweUpdates)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      bitrate_bps_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      detector_state_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_deltas_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DelayBasedBweUpdates::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bitrate_bps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bitrate_bps(&has_bits);
          bitrate_bps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.DelayBasedBweUpdates.DetectorState detector_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState_IsValid(val))) {
            _internal_set_detector_state(static_cast<::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes bitrate_bps_deltas = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_bitrate_bps_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes detector_state_deltas = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_detector_state_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DelayBasedBweUpdates::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.DelayBasedBweUpdates)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 bitrate_bps = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_bitrate_bps(), target);
  }

  // optional .webrtc.rtclog2.DelayBasedBweUpdates.DetectorState detector_state = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_detector_state(), target);
  }

  // optional uint32 number_of_deltas = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        101, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes bitrate_bps_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        102, this->_internal_bitrate_bps_deltas(), target);
  }

  // optional bytes detector_state_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        103, this->_internal_detector_state_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.DelayBasedBweUpdates)
  return target;
}

size_t DelayBasedBweUpdates::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.DelayBasedBweUpdates)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes bitrate_bps_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_bitrate_bps_deltas());
    }

    // optional bytes detector_state_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_detector_state_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 bitrate_bps = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bitrate_bps());
    }

    // optional .webrtc.rtclog2.DelayBasedBweUpdates.DetectorState detector_state = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_detector_state());
    }

    // optional uint32 number_of_deltas = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DelayBasedBweUpdates::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DelayBasedBweUpdates*>(
      &from));
}

void DelayBasedBweUpdates::MergeFrom(const DelayBasedBweUpdates& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.DelayBasedBweUpdates)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_bitrate_bps_deltas(from._internal_bitrate_bps_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_detector_state_deltas(from._internal_detector_state_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      bitrate_bps_ = from.bitrate_bps_;
    }
    if (cached_has_bits & 0x00000020u) {
      detector_state_ = from.detector_state_;
    }
    if (cached_has_bits & 0x00000040u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DelayBasedBweUpdates::CopyFrom(const DelayBasedBweUpdates& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.DelayBasedBweUpdates)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelayBasedBweUpdates::IsInitialized() const {
  return true;
}

void DelayBasedBweUpdates::InternalSwap(DelayBasedBweUpdates* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &bitrate_bps_deltas_, lhs_arena,
      &other->bitrate_bps_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &detector_state_deltas_, lhs_arena,
      &other->detector_state_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, number_of_deltas_)
      + sizeof(DelayBasedBweUpdates::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string DelayBasedBweUpdates::GetTypeName() const {
  return "webrtc.rtclog2.DelayBasedBweUpdates";
}


// ===================================================================

class RtpHeaderExtensionConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<RtpHeaderExtensionConfig>()._has_bits_);
  static void set_has_transmission_time_offset_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_absolute_send_time_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_transport_sequence_number_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_video_rotation_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_audio_level_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dependency_descriptor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

RtpHeaderExtensionConfig::RtpHeaderExtensionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.RtpHeaderExtensionConfig)
}
RtpHeaderExtensionConfig::RtpHeaderExtensionConfig(const RtpHeaderExtensionConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&transmission_time_offset_id_, &from.transmission_time_offset_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&dependency_descriptor_id_) -
    reinterpret_cast<char*>(&transmission_time_offset_id_)) + sizeof(dependency_descriptor_id_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.RtpHeaderExtensionConfig)
}

inline void RtpHeaderExtensionConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&transmission_time_offset_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dependency_descriptor_id_) -
    reinterpret_cast<char*>(&transmission_time_offset_id_)) + sizeof(dependency_descriptor_id_));
}

RtpHeaderExtensionConfig::~RtpHeaderExtensionConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.RtpHeaderExtensionConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RtpHeaderExtensionConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RtpHeaderExtensionConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RtpHeaderExtensionConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.RtpHeaderExtensionConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&transmission_time_offset_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dependency_descriptor_id_) -
        reinterpret_cast<char*>(&transmission_time_offset_id_)) + sizeof(dependency_descriptor_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RtpHeaderExtensionConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 transmission_time_offset_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_transmission_time_offset_id(&has_bits);
          transmission_time_offset_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 absolute_send_time_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_absolute_send_time_id(&has_bits);
          absolute_send_time_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 transport_sequence_number_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_transport_sequence_number_id(&has_bits);
          transport_sequence_number_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 video_rotation_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_video_rotation_id(&has_bits);
          video_rotation_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 audio_level_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_audio_level_id(&has_bits);
          audio_level_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dependency_descriptor_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dependency_descriptor_id(&has_bits);
          dependency_descriptor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RtpHeaderExtensionConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.RtpHeaderExtensionConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 transmission_time_offset_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_transmission_time_offset_id(), target);
  }

  // optional int32 absolute_send_time_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_absolute_send_time_id(), target);
  }

  // optional int32 transport_sequence_number_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_transport_sequence_number_id(), target);
  }

  // optional int32 video_rotation_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_video_rotation_id(), target);
  }

  // optional int32 audio_level_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_audio_level_id(), target);
  }

  // optional int32 dependency_descriptor_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_dependency_descriptor_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.RtpHeaderExtensionConfig)
  return target;
}

size_t RtpHeaderExtensionConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.RtpHeaderExtensionConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int32 transmission_time_offset_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_transmission_time_offset_id());
    }

    // optional int32 absolute_send_time_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_absolute_send_time_id());
    }

    // optional int32 transport_sequence_number_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_transport_sequence_number_id());
    }

    // optional int32 video_rotation_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_video_rotation_id());
    }

    // optional int32 audio_level_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_audio_level_id());
    }

    // optional int32 dependency_descriptor_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dependency_descriptor_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RtpHeaderExtensionConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RtpHeaderExtensionConfig*>(
      &from));
}

void RtpHeaderExtensionConfig::MergeFrom(const RtpHeaderExtensionConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.RtpHeaderExtensionConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      transmission_time_offset_id_ = from.transmission_time_offset_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      absolute_send_time_id_ = from.absolute_send_time_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      transport_sequence_number_id_ = from.transport_sequence_number_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      video_rotation_id_ = from.video_rotation_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      audio_level_id_ = from.audio_level_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      dependency_descriptor_id_ = from.dependency_descriptor_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RtpHeaderExtensionConfig::CopyFrom(const RtpHeaderExtensionConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.RtpHeaderExtensionConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RtpHeaderExtensionConfig::IsInitialized() const {
  return true;
}

void RtpHeaderExtensionConfig::InternalSwap(RtpHeaderExtensionConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, dependency_descriptor_id_)
      + sizeof(RtpHeaderExtensionConfig::dependency_descriptor_id_)
      - PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, transmission_time_offset_id_)>(
          reinterpret_cast<char*>(&transmission_time_offset_id_),
          reinterpret_cast<char*>(&other->transmission_time_offset_id_));
}

std::string RtpHeaderExtensionConfig::GetTypeName() const {
  return "webrtc.rtclog2.RtpHeaderExtensionConfig";
}


// ===================================================================

class VideoRecvStreamConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoRecvStreamConfig>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_remote_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_local_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rtx_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions(const VideoRecvStreamConfig* msg);
  static void set_has_header_extensions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::webrtc::rtclog2::RtpHeaderExtensionConfig&
VideoRecvStreamConfig::_Internal::header_extensions(const VideoRecvStreamConfig* msg) {
  return *msg->header_extensions_;
}
VideoRecvStreamConfig::VideoRecvStreamConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.VideoRecvStreamConfig)
}
VideoRecvStreamConfig::VideoRecvStreamConfig(const VideoRecvStreamConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header_extensions()) {
    header_extensions_ = new ::webrtc::rtclog2::RtpHeaderExtensionConfig(*from.header_extensions_);
  } else {
    header_extensions_ = nullptr;
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&rtx_ssrc_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(rtx_ssrc_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.VideoRecvStreamConfig)
}

inline void VideoRecvStreamConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&header_extensions_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rtx_ssrc_) -
    reinterpret_cast<char*>(&header_extensions_)) + sizeof(rtx_ssrc_));
}

VideoRecvStreamConfig::~VideoRecvStreamConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.VideoRecvStreamConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoRecvStreamConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_extensions_;
}

void VideoRecvStreamConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VideoRecvStreamConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.VideoRecvStreamConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(header_extensions_ != nullptr);
    header_extensions_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rtx_ssrc_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(rtx_ssrc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VideoRecvStreamConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 remote_ssrc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_remote_ssrc(&has_bits);
          remote_ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 local_ssrc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_local_ssrc(&has_bits);
          local_ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtx_ssrc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rtx_ssrc(&has_bits);
          rtx_ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_extensions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoRecvStreamConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.VideoRecvStreamConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 remote_ssrc = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_remote_ssrc(), target);
  }

  // optional uint32 local_ssrc = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_local_ssrc(), target);
  }

  // optional uint32 rtx_ssrc = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_rtx_ssrc(), target);
  }

  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::header_extensions(this),
        _Internal::header_extensions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.VideoRecvStreamConfig)
  return target;
}

size_t VideoRecvStreamConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.VideoRecvStreamConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_extensions_);
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 remote_ssrc = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_remote_ssrc());
    }

    // optional uint32 local_ssrc = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_local_ssrc());
    }

    // optional uint32 rtx_ssrc = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtx_ssrc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VideoRecvStreamConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VideoRecvStreamConfig*>(
      &from));
}

void VideoRecvStreamConfig::MergeFrom(const VideoRecvStreamConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.VideoRecvStreamConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header_extensions()->::webrtc::rtclog2::RtpHeaderExtensionConfig::MergeFrom(from._internal_header_extensions());
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      remote_ssrc_ = from.remote_ssrc_;
    }
    if (cached_has_bits & 0x00000008u) {
      local_ssrc_ = from.local_ssrc_;
    }
    if (cached_has_bits & 0x00000010u) {
      rtx_ssrc_ = from.rtx_ssrc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VideoRecvStreamConfig::CopyFrom(const VideoRecvStreamConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.VideoRecvStreamConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoRecvStreamConfig::IsInitialized() const {
  return true;
}

void VideoRecvStreamConfig::InternalSwap(VideoRecvStreamConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, rtx_ssrc_)
      + sizeof(VideoRecvStreamConfig::rtx_ssrc_)
      - PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, header_extensions_)>(
          reinterpret_cast<char*>(&header_extensions_),
          reinterpret_cast<char*>(&other->header_extensions_));
}

std::string VideoRecvStreamConfig::GetTypeName() const {
  return "webrtc.rtclog2.VideoRecvStreamConfig";
}


// ===================================================================

class VideoSendStreamConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoSendStreamConfig>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rtx_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions(const VideoSendStreamConfig* msg);
  static void set_has_header_extensions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::webrtc::rtclog2::RtpHeaderExtensionConfig&
VideoSendStreamConfig::_Internal::header_extensions(const VideoSendStreamConfig* msg) {
  return *msg->header_extensions_;
}
VideoSendStreamConfig::VideoSendStreamConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.VideoSendStreamConfig)
}
VideoSendStreamConfig::VideoSendStreamConfig(const VideoSendStreamConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header_extensions()) {
    header_extensions_ = new ::webrtc::rtclog2::RtpHeaderExtensionConfig(*from.header_extensions_);
  } else {
    header_extensions_ = nullptr;
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&rtx_ssrc_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(rtx_ssrc_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.VideoSendStreamConfig)
}

inline void VideoSendStreamConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&header_extensions_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rtx_ssrc_) -
    reinterpret_cast<char*>(&header_extensions_)) + sizeof(rtx_ssrc_));
}

VideoSendStreamConfig::~VideoSendStreamConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.VideoSendStreamConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoSendStreamConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_extensions_;
}

void VideoSendStreamConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VideoSendStreamConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.VideoSendStreamConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(header_extensions_ != nullptr);
    header_extensions_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rtx_ssrc_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(rtx_ssrc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VideoSendStreamConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ssrc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ssrc(&has_bits);
          ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtx_ssrc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_rtx_ssrc(&has_bits);
          rtx_ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_extensions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoSendStreamConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.VideoSendStreamConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 ssrc = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ssrc(), target);
  }

  // optional uint32 rtx_ssrc = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rtx_ssrc(), target);
  }

  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::header_extensions(this),
        _Internal::header_extensions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.VideoSendStreamConfig)
  return target;
}

size_t VideoSendStreamConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.VideoSendStreamConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_extensions_);
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 ssrc = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ssrc());
    }

    // optional uint32 rtx_ssrc = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtx_ssrc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VideoSendStreamConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VideoSendStreamConfig*>(
      &from));
}

void VideoSendStreamConfig::MergeFrom(const VideoSendStreamConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.VideoSendStreamConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header_extensions()->::webrtc::rtclog2::RtpHeaderExtensionConfig::MergeFrom(from._internal_header_extensions());
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      ssrc_ = from.ssrc_;
    }
    if (cached_has_bits & 0x00000008u) {
      rtx_ssrc_ = from.rtx_ssrc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VideoSendStreamConfig::CopyFrom(const VideoSendStreamConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.VideoSendStreamConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoSendStreamConfig::IsInitialized() const {
  return true;
}

void VideoSendStreamConfig::InternalSwap(VideoSendStreamConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, rtx_ssrc_)
      + sizeof(VideoSendStreamConfig::rtx_ssrc_)
      - PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, header_extensions_)>(
          reinterpret_cast<char*>(&header_extensions_),
          reinterpret_cast<char*>(&other->header_extensions_));
}

std::string VideoSendStreamConfig::GetTypeName() const {
  return "webrtc.rtclog2.VideoSendStreamConfig";
}


// ===================================================================

class AudioRecvStreamConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioRecvStreamConfig>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_remote_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_local_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions(const AudioRecvStreamConfig* msg);
  static void set_has_header_extensions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::webrtc::rtclog2::RtpHeaderExtensionConfig&
AudioRecvStreamConfig::_Internal::header_extensions(const AudioRecvStreamConfig* msg) {
  return *msg->header_extensions_;
}
AudioRecvStreamConfig::AudioRecvStreamConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.AudioRecvStreamConfig)
}
AudioRecvStreamConfig::AudioRecvStreamConfig(const AudioRecvStreamConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header_extensions()) {
    header_extensions_ = new ::webrtc::rtclog2::RtpHeaderExtensionConfig(*from.header_extensions_);
  } else {
    header_extensions_ = nullptr;
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&local_ssrc_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(local_ssrc_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.AudioRecvStreamConfig)
}

inline void AudioRecvStreamConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&header_extensions_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&local_ssrc_) -
    reinterpret_cast<char*>(&header_extensions_)) + sizeof(local_ssrc_));
}

AudioRecvStreamConfig::~AudioRecvStreamConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.AudioRecvStreamConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioRecvStreamConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_extensions_;
}

void AudioRecvStreamConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AudioRecvStreamConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.AudioRecvStreamConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(header_extensions_ != nullptr);
    header_extensions_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&local_ssrc_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(local_ssrc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioRecvStreamConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 remote_ssrc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_remote_ssrc(&has_bits);
          remote_ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 local_ssrc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_local_ssrc(&has_bits);
          local_ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_extensions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioRecvStreamConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.AudioRecvStreamConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 remote_ssrc = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_remote_ssrc(), target);
  }

  // optional uint32 local_ssrc = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_local_ssrc(), target);
  }

  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::header_extensions(this),
        _Internal::header_extensions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.AudioRecvStreamConfig)
  return target;
}

size_t AudioRecvStreamConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.AudioRecvStreamConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_extensions_);
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 remote_ssrc = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_remote_ssrc());
    }

    // optional uint32 local_ssrc = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_local_ssrc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioRecvStreamConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AudioRecvStreamConfig*>(
      &from));
}

void AudioRecvStreamConfig::MergeFrom(const AudioRecvStreamConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.AudioRecvStreamConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header_extensions()->::webrtc::rtclog2::RtpHeaderExtensionConfig::MergeFrom(from._internal_header_extensions());
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      remote_ssrc_ = from.remote_ssrc_;
    }
    if (cached_has_bits & 0x00000008u) {
      local_ssrc_ = from.local_ssrc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioRecvStreamConfig::CopyFrom(const AudioRecvStreamConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.AudioRecvStreamConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioRecvStreamConfig::IsInitialized() const {
  return true;
}

void AudioRecvStreamConfig::InternalSwap(AudioRecvStreamConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, local_ssrc_)
      + sizeof(AudioRecvStreamConfig::local_ssrc_)
      - PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, header_extensions_)>(
          reinterpret_cast<char*>(&header_extensions_),
          reinterpret_cast<char*>(&other->header_extensions_));
}

std::string AudioRecvStreamConfig::GetTypeName() const {
  return "webrtc.rtclog2.AudioRecvStreamConfig";
}


// ===================================================================

class AudioSendStreamConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioSendStreamConfig>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions(const AudioSendStreamConfig* msg);
  static void set_has_header_extensions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::webrtc::rtclog2::RtpHeaderExtensionConfig&
AudioSendStreamConfig::_Internal::header_extensions(const AudioSendStreamConfig* msg) {
  return *msg->header_extensions_;
}
AudioSendStreamConfig::AudioSendStreamConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.AudioSendStreamConfig)
}
AudioSendStreamConfig::AudioSendStreamConfig(const AudioSendStreamConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header_extensions()) {
    header_extensions_ = new ::webrtc::rtclog2::RtpHeaderExtensionConfig(*from.header_extensions_);
  } else {
    header_extensions_ = nullptr;
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&ssrc_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(ssrc_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.AudioSendStreamConfig)
}

inline void AudioSendStreamConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&header_extensions_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ssrc_) -
    reinterpret_cast<char*>(&header_extensions_)) + sizeof(ssrc_));
}

AudioSendStreamConfig::~AudioSendStreamConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.AudioSendStreamConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioSendStreamConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_extensions_;
}

void AudioSendStreamConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AudioSendStreamConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.AudioSendStreamConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(header_extensions_ != nullptr);
    header_extensions_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ssrc_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(ssrc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioSendStreamConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ssrc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ssrc(&has_bits);
          ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_extensions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioSendStreamConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.AudioSendStreamConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 ssrc = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ssrc(), target);
  }

  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::header_extensions(this),
        _Internal::header_extensions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.AudioSendStreamConfig)
  return target;
}

size_t AudioSendStreamConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.AudioSendStreamConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_extensions_);
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 ssrc = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ssrc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioSendStreamConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AudioSendStreamConfig*>(
      &from));
}

void AudioSendStreamConfig::MergeFrom(const AudioSendStreamConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.AudioSendStreamConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header_extensions()->::webrtc::rtclog2::RtpHeaderExtensionConfig::MergeFrom(from._internal_header_extensions());
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      ssrc_ = from.ssrc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioSendStreamConfig::CopyFrom(const AudioSendStreamConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.AudioSendStreamConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioSendStreamConfig::IsInitialized() const {
  return true;
}

void AudioSendStreamConfig::InternalSwap(AudioSendStreamConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, ssrc_)
      + sizeof(AudioSendStreamConfig::ssrc_)
      - PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, header_extensions_)>(
          reinterpret_cast<char*>(&header_extensions_),
          reinterpret_cast<char*>(&other->header_extensions_));
}

std::string AudioSendStreamConfig::GetTypeName() const {
  return "webrtc.rtclog2.AudioSendStreamConfig";
}


// ===================================================================

class AudioNetworkAdaptations::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioNetworkAdaptations>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_frame_length_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_uplink_packet_loss_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_enable_fec(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_enable_dtx(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_num_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bitrate_bps_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_frame_length_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_uplink_packet_loss_fraction_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_enable_fec_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_enable_dtx_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_channels_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

AudioNetworkAdaptations::AudioNetworkAdaptations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.AudioNetworkAdaptations)
}
AudioNetworkAdaptations::AudioNetworkAdaptations(const AudioNetworkAdaptations& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  bitrate_bps_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    bitrate_bps_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bitrate_bps_deltas()) {
    bitrate_bps_deltas_.Set(from._internal_bitrate_bps_deltas(), 
      GetArenaForAllocation());
  }
  frame_length_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    frame_length_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_frame_length_ms_deltas()) {
    frame_length_ms_deltas_.Set(from._internal_frame_length_ms_deltas(), 
      GetArenaForAllocation());
  }
  uplink_packet_loss_fraction_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    uplink_packet_loss_fraction_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uplink_packet_loss_fraction_deltas()) {
    uplink_packet_loss_fraction_deltas_.Set(from._internal_uplink_packet_loss_fraction_deltas(), 
      GetArenaForAllocation());
  }
  enable_fec_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    enable_fec_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_enable_fec_deltas()) {
    enable_fec_deltas_.Set(from._internal_enable_fec_deltas(), 
      GetArenaForAllocation());
  }
  enable_dtx_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    enable_dtx_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_enable_dtx_deltas()) {
    enable_dtx_deltas_.Set(from._internal_enable_dtx_deltas(), 
      GetArenaForAllocation());
  }
  num_channels_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    num_channels_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_num_channels_deltas()) {
    num_channels_deltas_.Set(from._internal_num_channels_deltas(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.AudioNetworkAdaptations)
}

inline void AudioNetworkAdaptations::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
bitrate_bps_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  bitrate_bps_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
frame_length_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  frame_length_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
uplink_packet_loss_fraction_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  uplink_packet_loss_fraction_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
enable_fec_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  enable_fec_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
enable_dtx_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  enable_dtx_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
num_channels_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  num_channels_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

AudioNetworkAdaptations::~AudioNetworkAdaptations() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.AudioNetworkAdaptations)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioNetworkAdaptations::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  bitrate_bps_deltas_.Destroy();
  frame_length_ms_deltas_.Destroy();
  uplink_packet_loss_fraction_deltas_.Destroy();
  enable_fec_deltas_.Destroy();
  enable_dtx_deltas_.Destroy();
  num_channels_deltas_.Destroy();
}

void AudioNetworkAdaptations::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AudioNetworkAdaptations::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.AudioNetworkAdaptations)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      bitrate_bps_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      frame_length_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      uplink_packet_loss_fraction_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      enable_fec_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      enable_dtx_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      num_channels_deltas_.ClearNonDefaultToEmpty();
    }
  }
  timestamp_ms_ = int64_t{0};
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&bitrate_bps_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_deltas_) -
        reinterpret_cast<char*>(&bitrate_bps_)) + sizeof(number_of_deltas_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioNetworkAdaptations::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bitrate_bps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bitrate_bps(&has_bits);
          bitrate_bps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 frame_length_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_frame_length_ms(&has_bits);
          frame_length_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 uplink_packet_loss_fraction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_uplink_packet_loss_fraction(&has_bits);
          uplink_packet_loss_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_fec = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_enable_fec(&has_bits);
          enable_fec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_dtx = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_enable_dtx(&has_bits);
          enable_dtx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_channels = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_num_channels(&has_bits);
          num_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes bitrate_bps_deltas = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_bitrate_bps_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes frame_length_ms_deltas = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_frame_length_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes uplink_packet_loss_fraction_deltas = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_uplink_packet_loss_fraction_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes enable_fec_deltas = 105;
      case 105:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_enable_fec_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes enable_dtx_deltas = 106;
      case 106:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_enable_dtx_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes num_channels_deltas = 107;
      case 107:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_num_channels_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioNetworkAdaptations::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.AudioNetworkAdaptations)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional int32 bitrate_bps = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_bitrate_bps(), target);
  }

  // optional int32 frame_length_ms = 3;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_frame_length_ms(), target);
  }

  // optional uint32 uplink_packet_loss_fraction = 4;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_uplink_packet_loss_fraction(), target);
  }

  // optional bool enable_fec = 5;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_enable_fec(), target);
  }

  // optional bool enable_dtx = 6;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_enable_dtx(), target);
  }

  // optional uint32 num_channels = 7;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_num_channels(), target);
  }

  // optional uint32 number_of_deltas = 8;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        101, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes bitrate_bps_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        102, this->_internal_bitrate_bps_deltas(), target);
  }

  // optional bytes frame_length_ms_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        103, this->_internal_frame_length_ms_deltas(), target);
  }

  // optional bytes uplink_packet_loss_fraction_deltas = 104;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        104, this->_internal_uplink_packet_loss_fraction_deltas(), target);
  }

  // optional bytes enable_fec_deltas = 105;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        105, this->_internal_enable_fec_deltas(), target);
  }

  // optional bytes enable_dtx_deltas = 106;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        106, this->_internal_enable_dtx_deltas(), target);
  }

  // optional bytes num_channels_deltas = 107;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        107, this->_internal_num_channels_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.AudioNetworkAdaptations)
  return target;
}

size_t AudioNetworkAdaptations::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.AudioNetworkAdaptations)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes bitrate_bps_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_bitrate_bps_deltas());
    }

    // optional bytes frame_length_ms_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_frame_length_ms_deltas());
    }

    // optional bytes uplink_packet_loss_fraction_deltas = 104;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_uplink_packet_loss_fraction_deltas());
    }

    // optional bytes enable_fec_deltas = 105;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_enable_fec_deltas());
    }

    // optional bytes enable_dtx_deltas = 106;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_enable_dtx_deltas());
    }

    // optional bytes num_channels_deltas = 107;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_num_channels_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional int32 bitrate_bps = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bitrate_bps());
    }

    // optional int32 frame_length_ms = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_frame_length_ms());
    }

    // optional uint32 uplink_packet_loss_fraction = 4;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uplink_packet_loss_fraction());
    }

    // optional bool enable_fec = 5;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool enable_dtx = 6;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional uint32 num_channels = 7;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());
    }

    // optional uint32 number_of_deltas = 8;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioNetworkAdaptations::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AudioNetworkAdaptations*>(
      &from));
}

void AudioNetworkAdaptations::MergeFrom(const AudioNetworkAdaptations& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.AudioNetworkAdaptations)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_bitrate_bps_deltas(from._internal_bitrate_bps_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_frame_length_ms_deltas(from._internal_frame_length_ms_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_uplink_packet_loss_fraction_deltas(from._internal_uplink_packet_loss_fraction_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_enable_fec_deltas(from._internal_enable_fec_deltas());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_enable_dtx_deltas(from._internal_enable_dtx_deltas());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_num_channels_deltas(from._internal_num_channels_deltas());
    }
    if (cached_has_bits & 0x00000080u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      bitrate_bps_ = from.bitrate_bps_;
    }
    if (cached_has_bits & 0x00000200u) {
      frame_length_ms_ = from.frame_length_ms_;
    }
    if (cached_has_bits & 0x00000400u) {
      uplink_packet_loss_fraction_ = from.uplink_packet_loss_fraction_;
    }
    if (cached_has_bits & 0x00000800u) {
      enable_fec_ = from.enable_fec_;
    }
    if (cached_has_bits & 0x00001000u) {
      enable_dtx_ = from.enable_dtx_;
    }
    if (cached_has_bits & 0x00002000u) {
      num_channels_ = from.num_channels_;
    }
    if (cached_has_bits & 0x00004000u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioNetworkAdaptations::CopyFrom(const AudioNetworkAdaptations& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.AudioNetworkAdaptations)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioNetworkAdaptations::IsInitialized() const {
  return true;
}

void AudioNetworkAdaptations::InternalSwap(AudioNetworkAdaptations* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &bitrate_bps_deltas_, lhs_arena,
      &other->bitrate_bps_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &frame_length_ms_deltas_, lhs_arena,
      &other->frame_length_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &uplink_packet_loss_fraction_deltas_, lhs_arena,
      &other->uplink_packet_loss_fraction_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &enable_fec_deltas_, lhs_arena,
      &other->enable_fec_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &enable_dtx_deltas_, lhs_arena,
      &other->enable_dtx_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &num_channels_deltas_, lhs_arena,
      &other->num_channels_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, number_of_deltas_)
      + sizeof(AudioNetworkAdaptations::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string AudioNetworkAdaptations::GetTypeName() const {
  return "webrtc.rtclog2.AudioNetworkAdaptations";
}


// ===================================================================

class BweProbeCluster::_Internal {
 public:
  using HasBits = decltype(std::declval<BweProbeCluster>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_min_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_min_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

BweProbeCluster::BweProbeCluster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.BweProbeCluster)
}
BweProbeCluster::BweProbeCluster(const BweProbeCluster& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&min_bytes_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(min_bytes_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.BweProbeCluster)
}

inline void BweProbeCluster::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&min_bytes_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(min_bytes_));
}

BweProbeCluster::~BweProbeCluster() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.BweProbeCluster)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BweProbeCluster::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BweProbeCluster::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BweProbeCluster::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.BweProbeCluster)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&min_bytes_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(min_bytes_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BweProbeCluster::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bitrate_bps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_bitrate_bps(&has_bits);
          bitrate_bps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 min_packets = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_min_packets(&has_bits);
          min_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 min_bytes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_min_bytes(&has_bits);
          min_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BweProbeCluster::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.BweProbeCluster)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_id(), target);
  }

  // optional uint32 bitrate_bps = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_bitrate_bps(), target);
  }

  // optional uint32 min_packets = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_min_packets(), target);
  }

  // optional uint32 min_bytes = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_min_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.BweProbeCluster)
  return target;
}

size_t BweProbeCluster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.BweProbeCluster)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional uint32 bitrate_bps = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bitrate_bps());
    }

    // optional uint32 min_packets = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_min_packets());
    }

    // optional uint32 min_bytes = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_min_bytes());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BweProbeCluster::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BweProbeCluster*>(
      &from));
}

void BweProbeCluster::MergeFrom(const BweProbeCluster& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.BweProbeCluster)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      bitrate_bps_ = from.bitrate_bps_;
    }
    if (cached_has_bits & 0x00000008u) {
      min_packets_ = from.min_packets_;
    }
    if (cached_has_bits & 0x00000010u) {
      min_bytes_ = from.min_bytes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BweProbeCluster::CopyFrom(const BweProbeCluster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.BweProbeCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BweProbeCluster::IsInitialized() const {
  return true;
}

void BweProbeCluster::InternalSwap(BweProbeCluster* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BweProbeCluster, min_bytes_)
      + sizeof(BweProbeCluster::min_bytes_)
      - PROTOBUF_FIELD_OFFSET(BweProbeCluster, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string BweProbeCluster::GetTypeName() const {
  return "webrtc.rtclog2.BweProbeCluster";
}


// ===================================================================

class BweProbeResultSuccess::_Internal {
 public:
  using HasBits = decltype(std::declval<BweProbeResultSuccess>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

BweProbeResultSuccess::BweProbeResultSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.BweProbeResultSuccess)
}
BweProbeResultSuccess::BweProbeResultSuccess(const BweProbeResultSuccess& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&bitrate_bps_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(bitrate_bps_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.BweProbeResultSuccess)
}

inline void BweProbeResultSuccess::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&bitrate_bps_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(bitrate_bps_));
}

BweProbeResultSuccess::~BweProbeResultSuccess() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.BweProbeResultSuccess)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BweProbeResultSuccess::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BweProbeResultSuccess::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BweProbeResultSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.BweProbeResultSuccess)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&bitrate_bps_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(bitrate_bps_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BweProbeResultSuccess::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bitrate_bps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_bitrate_bps(&has_bits);
          bitrate_bps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BweProbeResultSuccess::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.BweProbeResultSuccess)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_id(), target);
  }

  // optional uint32 bitrate_bps = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_bitrate_bps(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.BweProbeResultSuccess)
  return target;
}

size_t BweProbeResultSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.BweProbeResultSuccess)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional uint32 bitrate_bps = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bitrate_bps());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BweProbeResultSuccess::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BweProbeResultSuccess*>(
      &from));
}

void BweProbeResultSuccess::MergeFrom(const BweProbeResultSuccess& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.BweProbeResultSuccess)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      bitrate_bps_ = from.bitrate_bps_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BweProbeResultSuccess::CopyFrom(const BweProbeResultSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.BweProbeResultSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BweProbeResultSuccess::IsInitialized() const {
  return true;
}

void BweProbeResultSuccess::InternalSwap(BweProbeResultSuccess* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, bitrate_bps_)
      + sizeof(BweProbeResultSuccess::bitrate_bps_)
      - PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string BweProbeResultSuccess::GetTypeName() const {
  return "webrtc.rtclog2.BweProbeResultSuccess";
}


// ===================================================================

class BweProbeResultFailure::_Internal {
 public:
  using HasBits = decltype(std::declval<BweProbeResultFailure>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_failure(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

BweProbeResultFailure::BweProbeResultFailure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.BweProbeResultFailure)
}
BweProbeResultFailure::BweProbeResultFailure(const BweProbeResultFailure& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&failure_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(failure_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.BweProbeResultFailure)
}

inline void BweProbeResultFailure::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&failure_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(failure_));
}

BweProbeResultFailure::~BweProbeResultFailure() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.BweProbeResultFailure)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BweProbeResultFailure::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BweProbeResultFailure::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BweProbeResultFailure::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.BweProbeResultFailure)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&failure_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(failure_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BweProbeResultFailure::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.BweProbeResultFailure.FailureReason failure = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::BweProbeResultFailure_FailureReason_IsValid(val))) {
            _internal_set_failure(static_cast<::webrtc::rtclog2::BweProbeResultFailure_FailureReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BweProbeResultFailure::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.BweProbeResultFailure)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_id(), target);
  }

  // optional .webrtc.rtclog2.BweProbeResultFailure.FailureReason failure = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_failure(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.BweProbeResultFailure)
  return target;
}

size_t BweProbeResultFailure::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.BweProbeResultFailure)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional .webrtc.rtclog2.BweProbeResultFailure.FailureReason failure = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_failure());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BweProbeResultFailure::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BweProbeResultFailure*>(
      &from));
}

void BweProbeResultFailure::MergeFrom(const BweProbeResultFailure& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.BweProbeResultFailure)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      failure_ = from.failure_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BweProbeResultFailure::CopyFrom(const BweProbeResultFailure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.BweProbeResultFailure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BweProbeResultFailure::IsInitialized() const {
  return true;
}

void BweProbeResultFailure::InternalSwap(BweProbeResultFailure* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, failure_)
      + sizeof(BweProbeResultFailure::failure_)
      - PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string BweProbeResultFailure::GetTypeName() const {
  return "webrtc.rtclog2.BweProbeResultFailure";
}


// ===================================================================

class AlrState::_Internal {
 public:
  using HasBits = decltype(std::declval<AlrState>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_in_alr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AlrState::AlrState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.AlrState)
}
AlrState::AlrState(const AlrState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&in_alr_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(in_alr_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.AlrState)
}

inline void AlrState::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&in_alr_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(in_alr_));
}

AlrState::~AlrState() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.AlrState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AlrState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AlrState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AlrState::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.AlrState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&in_alr_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(in_alr_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AlrState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool in_alr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_in_alr(&has_bits);
          in_alr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AlrState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.AlrState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional bool in_alr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_in_alr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.AlrState)
  return target;
}

size_t AlrState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.AlrState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional bool in_alr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AlrState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AlrState*>(
      &from));
}

void AlrState::MergeFrom(const AlrState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.AlrState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      in_alr_ = from.in_alr_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AlrState::CopyFrom(const AlrState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.AlrState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AlrState::IsInitialized() const {
  return true;
}

void AlrState::InternalSwap(AlrState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AlrState, in_alr_)
      + sizeof(AlrState::in_alr_)
      - PROTOBUF_FIELD_OFFSET(AlrState, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string AlrState::GetTypeName() const {
  return "webrtc.rtclog2.AlrState";
}


// ===================================================================

class IceCandidatePairConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<IceCandidatePairConfig>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_config_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_candidate_pair_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_local_candidate_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_local_relay_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_local_network_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_local_address_family(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_remote_candidate_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_remote_address_family(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_candidate_pair_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

IceCandidatePairConfig::IceCandidatePairConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.IceCandidatePairConfig)
}
IceCandidatePairConfig::IceCandidatePairConfig(const IceCandidatePairConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&candidate_pair_protocol_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(candidate_pair_protocol_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.IceCandidatePairConfig)
}

inline void IceCandidatePairConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&candidate_pair_protocol_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(candidate_pair_protocol_));
}

IceCandidatePairConfig::~IceCandidatePairConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.IceCandidatePairConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IceCandidatePairConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IceCandidatePairConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IceCandidatePairConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.IceCandidatePairConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&remote_candidate_type_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(remote_candidate_type_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&remote_address_family_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&candidate_pair_protocol_) -
        reinterpret_cast<char*>(&remote_address_family_)) + sizeof(candidate_pair_protocol_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IceCandidatePairConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidatePairConfigType config_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType_IsValid(val))) {
            _internal_set_config_type(static_cast<::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 candidate_pair_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_candidate_pair_id(&has_bits);
          candidate_pair_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType local_candidate_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType_IsValid(val))) {
            _internal_set_local_candidate_type(static_cast<::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol local_relay_protocol = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::IceCandidatePairConfig_Protocol_IsValid(val))) {
            _internal_set_local_relay_protocol(static_cast<::webrtc::rtclog2::IceCandidatePairConfig_Protocol>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.IceCandidatePairConfig.NetworkType local_network_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::IceCandidatePairConfig_NetworkType_IsValid(val))) {
            _internal_set_local_network_type(static_cast<::webrtc::rtclog2::IceCandidatePairConfig_NetworkType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily local_address_family = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily_IsValid(val))) {
            _internal_set_local_address_family(static_cast<::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType remote_candidate_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType_IsValid(val))) {
            _internal_set_remote_candidate_type(static_cast<::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily remote_address_family = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily_IsValid(val))) {
            _internal_set_remote_address_family(static_cast<::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol candidate_pair_protocol = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::IceCandidatePairConfig_Protocol_IsValid(val))) {
            _internal_set_candidate_pair_protocol(static_cast<::webrtc::rtclog2::IceCandidatePairConfig_Protocol>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IceCandidatePairConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.IceCandidatePairConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidatePairConfigType config_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_config_type(), target);
  }

  // optional uint32 candidate_pair_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_candidate_pair_id(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType local_candidate_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_local_candidate_type(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol local_relay_protocol = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_local_relay_protocol(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.NetworkType local_network_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_local_network_type(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily local_address_family = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_local_address_family(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType remote_candidate_type = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_remote_candidate_type(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily remote_address_family = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_remote_address_family(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol candidate_pair_protocol = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_candidate_pair_protocol(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.IceCandidatePairConfig)
  return target;
}

size_t IceCandidatePairConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.IceCandidatePairConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidatePairConfigType config_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_config_type());
    }

    // optional uint32 candidate_pair_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_candidate_pair_id());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType local_candidate_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_local_candidate_type());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol local_relay_protocol = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_local_relay_protocol());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.NetworkType local_network_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_local_network_type());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily local_address_family = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_local_address_family());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType remote_candidate_type = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_remote_candidate_type());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily remote_address_family = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_remote_address_family());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol candidate_pair_protocol = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_candidate_pair_protocol());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IceCandidatePairConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IceCandidatePairConfig*>(
      &from));
}

void IceCandidatePairConfig::MergeFrom(const IceCandidatePairConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.IceCandidatePairConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      config_type_ = from.config_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      candidate_pair_id_ = from.candidate_pair_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      local_candidate_type_ = from.local_candidate_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      local_relay_protocol_ = from.local_relay_protocol_;
    }
    if (cached_has_bits & 0x00000020u) {
      local_network_type_ = from.local_network_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      local_address_family_ = from.local_address_family_;
    }
    if (cached_has_bits & 0x00000080u) {
      remote_candidate_type_ = from.remote_candidate_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      remote_address_family_ = from.remote_address_family_;
    }
    if (cached_has_bits & 0x00000200u) {
      candidate_pair_protocol_ = from.candidate_pair_protocol_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IceCandidatePairConfig::CopyFrom(const IceCandidatePairConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.IceCandidatePairConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IceCandidatePairConfig::IsInitialized() const {
  return true;
}

void IceCandidatePairConfig::InternalSwap(IceCandidatePairConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, candidate_pair_protocol_)
      + sizeof(IceCandidatePairConfig::candidate_pair_protocol_)
      - PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string IceCandidatePairConfig::GetTypeName() const {
  return "webrtc.rtclog2.IceCandidatePairConfig";
}


// ===================================================================

class IceCandidatePairEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IceCandidatePairEvent>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_candidate_pair_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_transaction_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IceCandidatePairEvent::IceCandidatePairEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.IceCandidatePairEvent)
}
IceCandidatePairEvent::IceCandidatePairEvent(const IceCandidatePairEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&transaction_id_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(transaction_id_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.IceCandidatePairEvent)
}

inline void IceCandidatePairEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&transaction_id_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(transaction_id_));
}

IceCandidatePairEvent::~IceCandidatePairEvent() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.IceCandidatePairEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IceCandidatePairEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IceCandidatePairEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IceCandidatePairEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.IceCandidatePairEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&transaction_id_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(transaction_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IceCandidatePairEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.IceCandidatePairEvent.IceCandidatePairEventType event_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType_IsValid(val))) {
            _internal_set_event_type(static_cast<::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 candidate_pair_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_candidate_pair_id(&has_bits);
          candidate_pair_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 transaction_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_transaction_id(&has_bits);
          transaction_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IceCandidatePairEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.IceCandidatePairEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairEvent.IceCandidatePairEventType event_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_event_type(), target);
  }

  // optional uint32 candidate_pair_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_candidate_pair_id(), target);
  }

  // optional uint32 transaction_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_transaction_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.IceCandidatePairEvent)
  return target;
}

size_t IceCandidatePairEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.IceCandidatePairEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional .webrtc.rtclog2.IceCandidatePairEvent.IceCandidatePairEventType event_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_type());
    }

    // optional uint32 candidate_pair_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_candidate_pair_id());
    }

    // optional uint32 transaction_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_transaction_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IceCandidatePairEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IceCandidatePairEvent*>(
      &from));
}

void IceCandidatePairEvent::MergeFrom(const IceCandidatePairEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.IceCandidatePairEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      event_type_ = from.event_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      candidate_pair_id_ = from.candidate_pair_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      transaction_id_ = from.transaction_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IceCandidatePairEvent::CopyFrom(const IceCandidatePairEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.IceCandidatePairEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IceCandidatePairEvent::IsInitialized() const {
  return true;
}

void IceCandidatePairEvent::InternalSwap(IceCandidatePairEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, transaction_id_)
      + sizeof(IceCandidatePairEvent::transaction_id_)
      - PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string IceCandidatePairEvent::GetTypeName() const {
  return "webrtc.rtclog2.IceCandidatePairEvent";
}


// ===================================================================

class DtlsTransportStateEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<DtlsTransportStateEvent>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dtls_transport_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DtlsTransportStateEvent::DtlsTransportStateEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.DtlsTransportStateEvent)
}
DtlsTransportStateEvent::DtlsTransportStateEvent(const DtlsTransportStateEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&dtls_transport_state_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(dtls_transport_state_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.DtlsTransportStateEvent)
}

inline void DtlsTransportStateEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dtls_transport_state_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(dtls_transport_state_));
}

DtlsTransportStateEvent::~DtlsTransportStateEvent() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.DtlsTransportStateEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DtlsTransportStateEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DtlsTransportStateEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DtlsTransportStateEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.DtlsTransportStateEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dtls_transport_state_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(dtls_transport_state_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DtlsTransportStateEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .webrtc.rtclog2.DtlsTransportStateEvent.DtlsTransportState dtls_transport_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState_IsValid(val))) {
            _internal_set_dtls_transport_state(static_cast<::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DtlsTransportStateEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.DtlsTransportStateEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional .webrtc.rtclog2.DtlsTransportStateEvent.DtlsTransportState dtls_transport_state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_dtls_transport_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.DtlsTransportStateEvent)
  return target;
}

size_t DtlsTransportStateEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.DtlsTransportStateEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional .webrtc.rtclog2.DtlsTransportStateEvent.DtlsTransportState dtls_transport_state = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_dtls_transport_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DtlsTransportStateEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DtlsTransportStateEvent*>(
      &from));
}

void DtlsTransportStateEvent::MergeFrom(const DtlsTransportStateEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.DtlsTransportStateEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      dtls_transport_state_ = from.dtls_transport_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DtlsTransportStateEvent::CopyFrom(const DtlsTransportStateEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.DtlsTransportStateEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DtlsTransportStateEvent::IsInitialized() const {
  return true;
}

void DtlsTransportStateEvent::InternalSwap(DtlsTransportStateEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DtlsTransportStateEvent, dtls_transport_state_)
      + sizeof(DtlsTransportStateEvent::dtls_transport_state_)
      - PROTOBUF_FIELD_OFFSET(DtlsTransportStateEvent, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string DtlsTransportStateEvent::GetTypeName() const {
  return "webrtc.rtclog2.DtlsTransportStateEvent";
}


// ===================================================================

class DtlsWritableState::_Internal {
 public:
  using HasBits = decltype(std::declval<DtlsWritableState>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_writable(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DtlsWritableState::DtlsWritableState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.DtlsWritableState)
}
DtlsWritableState::DtlsWritableState(const DtlsWritableState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&writable_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(writable_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.DtlsWritableState)
}

inline void DtlsWritableState::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&writable_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(writable_));
}

DtlsWritableState::~DtlsWritableState() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.DtlsWritableState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DtlsWritableState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DtlsWritableState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DtlsWritableState::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.DtlsWritableState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&writable_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(writable_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DtlsWritableState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool writable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_writable(&has_bits);
          writable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DtlsWritableState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.DtlsWritableState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional bool writable = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_writable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.DtlsWritableState)
  return target;
}

size_t DtlsWritableState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.DtlsWritableState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional bool writable = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DtlsWritableState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DtlsWritableState*>(
      &from));
}

void DtlsWritableState::MergeFrom(const DtlsWritableState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.DtlsWritableState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      writable_ = from.writable_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DtlsWritableState::CopyFrom(const DtlsWritableState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.DtlsWritableState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DtlsWritableState::IsInitialized() const {
  return true;
}

void DtlsWritableState::InternalSwap(DtlsWritableState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DtlsWritableState, writable_)
      + sizeof(DtlsWritableState::writable_)
      - PROTOBUF_FIELD_OFFSET(DtlsWritableState, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string DtlsWritableState::GetTypeName() const {
  return "webrtc.rtclog2.DtlsWritableState";
}


// ===================================================================

class RouteChange::_Internal {
 public:
  using HasBits = decltype(std::declval<RouteChange>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_overhead(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

RouteChange::RouteChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.RouteChange)
}
RouteChange::RouteChange(const RouteChange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&overhead_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(overhead_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.RouteChange)
}

inline void RouteChange::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&overhead_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(overhead_));
}

RouteChange::~RouteChange() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.RouteChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouteChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RouteChange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RouteChange::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.RouteChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&overhead_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(overhead_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RouteChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool connected = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_connected(&has_bits);
          connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 overhead = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_overhead(&has_bits);
          overhead_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouteChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.RouteChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional bool connected = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_connected(), target);
  }

  // optional uint32 overhead = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_overhead(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.RouteChange)
  return target;
}

size_t RouteChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.RouteChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional bool connected = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 overhead = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overhead());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RouteChange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RouteChange*>(
      &from));
}

void RouteChange::MergeFrom(const RouteChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.RouteChange)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      connected_ = from.connected_;
    }
    if (cached_has_bits & 0x00000004u) {
      overhead_ = from.overhead_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RouteChange::CopyFrom(const RouteChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.RouteChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteChange::IsInitialized() const {
  return true;
}

void RouteChange::InternalSwap(RouteChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RouteChange, overhead_)
      + sizeof(RouteChange::overhead_)
      - PROTOBUF_FIELD_OFFSET(RouteChange, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string RouteChange::GetTypeName() const {
  return "webrtc.rtclog2.RouteChange";
}


// ===================================================================

class RemoteEstimates::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoteEstimates>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_link_capacity_lower_kbps(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_link_capacity_upper_kbps(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_link_capacity_lower_kbps_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_link_capacity_upper_kbps_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

RemoteEstimates::RemoteEstimates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.RemoteEstimates)
}
RemoteEstimates::RemoteEstimates(const RemoteEstimates& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timestamp_ms_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    timestamp_ms_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp_ms_deltas()) {
    timestamp_ms_deltas_.Set(from._internal_timestamp_ms_deltas(), 
      GetArenaForAllocation());
  }
  link_capacity_lower_kbps_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    link_capacity_lower_kbps_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_link_capacity_lower_kbps_deltas()) {
    link_capacity_lower_kbps_deltas_.Set(from._internal_link_capacity_lower_kbps_deltas(), 
      GetArenaForAllocation());
  }
  link_capacity_upper_kbps_deltas_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    link_capacity_upper_kbps_deltas_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_link_capacity_upper_kbps_deltas()) {
    link_capacity_upper_kbps_deltas_.Set(from._internal_link_capacity_upper_kbps_deltas(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.RemoteEstimates)
}

inline void RemoteEstimates::SharedCtor() {
timestamp_ms_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  timestamp_ms_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
link_capacity_lower_kbps_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  link_capacity_lower_kbps_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
link_capacity_upper_kbps_deltas_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  link_capacity_upper_kbps_deltas_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_deltas_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
}

RemoteEstimates::~RemoteEstimates() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.RemoteEstimates)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoteEstimates::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  timestamp_ms_deltas_.Destroy();
  link_capacity_lower_kbps_deltas_.Destroy();
  link_capacity_upper_kbps_deltas_.Destroy();
}

void RemoteEstimates::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RemoteEstimates::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.RemoteEstimates)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      link_capacity_lower_kbps_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      link_capacity_upper_kbps_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_deltas_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(number_of_deltas_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RemoteEstimates::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 link_capacity_lower_kbps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_link_capacity_lower_kbps(&has_bits);
          link_capacity_lower_kbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 link_capacity_upper_kbps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_link_capacity_upper_kbps(&has_bits);
          link_capacity_upper_kbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_deltas = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_number_of_deltas(&has_bits);
          number_of_deltas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes timestamp_ms_deltas = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timestamp_ms_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes link_capacity_lower_kbps_deltas = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_link_capacity_lower_kbps_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes link_capacity_upper_kbps_deltas = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_link_capacity_upper_kbps_deltas();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoteEstimates::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.RemoteEstimates)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 link_capacity_lower_kbps = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_link_capacity_lower_kbps(), target);
  }

  // optional uint32 link_capacity_upper_kbps = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_link_capacity_upper_kbps(), target);
  }

  // optional uint32 number_of_deltas = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        101, this->_internal_timestamp_ms_deltas(), target);
  }

  // optional bytes link_capacity_lower_kbps_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        102, this->_internal_link_capacity_lower_kbps_deltas(), target);
  }

  // optional bytes link_capacity_upper_kbps_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        103, this->_internal_link_capacity_upper_kbps_deltas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.RemoteEstimates)
  return target;
}

size_t RemoteEstimates::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.RemoteEstimates)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_timestamp_ms_deltas());
    }

    // optional bytes link_capacity_lower_kbps_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_link_capacity_lower_kbps_deltas());
    }

    // optional bytes link_capacity_upper_kbps_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_link_capacity_upper_kbps_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint32 link_capacity_lower_kbps = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_link_capacity_lower_kbps());
    }

    // optional uint32 link_capacity_upper_kbps = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_link_capacity_upper_kbps());
    }

    // optional uint32 number_of_deltas = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RemoteEstimates::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RemoteEstimates*>(
      &from));
}

void RemoteEstimates::MergeFrom(const RemoteEstimates& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.RemoteEstimates)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_link_capacity_lower_kbps_deltas(from._internal_link_capacity_lower_kbps_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_link_capacity_upper_kbps_deltas(from._internal_link_capacity_upper_kbps_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      link_capacity_lower_kbps_ = from.link_capacity_lower_kbps_;
    }
    if (cached_has_bits & 0x00000020u) {
      link_capacity_upper_kbps_ = from.link_capacity_upper_kbps_;
    }
    if (cached_has_bits & 0x00000040u) {
      number_of_deltas_ = from.number_of_deltas_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RemoteEstimates::CopyFrom(const RemoteEstimates& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.RemoteEstimates)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteEstimates::IsInitialized() const {
  return true;
}

void RemoteEstimates::InternalSwap(RemoteEstimates* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &timestamp_ms_deltas_, lhs_arena,
      &other->timestamp_ms_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &link_capacity_lower_kbps_deltas_, lhs_arena,
      &other->link_capacity_lower_kbps_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &link_capacity_upper_kbps_deltas_, lhs_arena,
      &other->link_capacity_upper_kbps_deltas_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoteEstimates, number_of_deltas_)
      + sizeof(RemoteEstimates::number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(RemoteEstimates, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string RemoteEstimates::GetTypeName() const {
  return "webrtc.rtclog2.RemoteEstimates";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace rtclog2
}  // namespace webrtc
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::EventStream*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::EventStream >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::EventStream >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::Event*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::Event >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::Event >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::GenericPacketReceived*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::GenericPacketReceived >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::GenericPacketReceived >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::GenericPacketSent*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::GenericPacketSent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::GenericPacketSent >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::GenericAckReceived*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::GenericAckReceived >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::GenericAckReceived >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::DependencyDescriptorsWireInfo*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::DependencyDescriptorsWireInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::DependencyDescriptorsWireInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::IncomingRtpPackets*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::IncomingRtpPackets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::IncomingRtpPackets >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::OutgoingRtpPackets*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::OutgoingRtpPackets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::OutgoingRtpPackets >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::IncomingRtcpPackets*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::IncomingRtcpPackets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::IncomingRtcpPackets >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::OutgoingRtcpPackets*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::OutgoingRtcpPackets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::OutgoingRtcpPackets >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::AudioPlayoutEvents*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::AudioPlayoutEvents >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::AudioPlayoutEvents >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::NetEqSetMinimumDelay*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::NetEqSetMinimumDelay >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::NetEqSetMinimumDelay >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::FrameDecodedEvents*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::FrameDecodedEvents >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::FrameDecodedEvents >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::BeginLogEvent*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::BeginLogEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::BeginLogEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::EndLogEvent*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::EndLogEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::EndLogEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::LossBasedBweUpdates*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::LossBasedBweUpdates >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::LossBasedBweUpdates >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::DelayBasedBweUpdates*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::DelayBasedBweUpdates >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::DelayBasedBweUpdates >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::RtpHeaderExtensionConfig*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::RtpHeaderExtensionConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::RtpHeaderExtensionConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::VideoRecvStreamConfig*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::VideoRecvStreamConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::VideoRecvStreamConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::VideoSendStreamConfig*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::VideoSendStreamConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::VideoSendStreamConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::AudioRecvStreamConfig*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::AudioRecvStreamConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::AudioRecvStreamConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::AudioSendStreamConfig*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::AudioSendStreamConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::AudioSendStreamConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::AudioNetworkAdaptations*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::AudioNetworkAdaptations >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::AudioNetworkAdaptations >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::BweProbeCluster*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::BweProbeCluster >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::BweProbeCluster >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::BweProbeResultSuccess*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::BweProbeResultSuccess >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::BweProbeResultSuccess >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::BweProbeResultFailure*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::BweProbeResultFailure >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::BweProbeResultFailure >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::AlrState*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::AlrState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::AlrState >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::IceCandidatePairConfig*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::IceCandidatePairConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::IceCandidatePairConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::IceCandidatePairEvent*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::IceCandidatePairEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::IceCandidatePairEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::DtlsTransportStateEvent*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::DtlsTransportStateEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::DtlsTransportStateEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::DtlsWritableState*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::DtlsWritableState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::DtlsWritableState >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::RouteChange*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::RouteChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::RouteChange >(arena);
}
template<> PROTOBUF_NOINLINE ::webrtc::rtclog2::RemoteEstimates*
Arena::CreateMaybeMessage< ::webrtc::rtclog2::RemoteEstimates >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webrtc::rtclog2::RemoteEstimates >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
